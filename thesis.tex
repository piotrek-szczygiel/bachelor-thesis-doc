\documentclass[polish,12pt]{aghthesis}
\usepackage[utf8x]{inputenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{float}
\usepackage{perpage}

\MakePerPage{footnote}

\graphicspath{ {./images/} }

\author{Piotr Szczygieł}

\titlePL{Gra typu Capture-The-Flag\\ oparta o reverse engineering}
\titleEN{Capture-The-Flag game based on reverse engineering}

\fieldofstudy{Informatyka}

\supervisor{dr inż.\ Łukasz Faber}

\date{\the\year}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{\SectionTitleProjectVision}
\label{sec:cel-wizja}

\subsection{Wprowadzenie}

Gra typu Capture-the-Flag jest to rodzaj zawodów z ogólnie pojętego
bezpieczeństwa komputerowego. Ich celem zwykle jest edukacja uczestników
o zabezpieczeniach systemów oraz możliwość pokazania im jak reagować
na wypadek wystąpienia rzeczywistych ataków. Zawody takie podzielone są zazwyczaj
na poszczególne zadania z różnych kategorii. Aby rozwiązać takie zadanie należy
znaleźć ,,flagę'', którą następnie podaje się w interfejsie udostępnionym przez
organizatora zawodów. Flagą w tym wypadku jest ciąg znaków, który możemy uzyskać
poprzez rozwiązanie zadania. Przykładowo w najprostszych zadaniach
z dziedziny eksploitacji stron internetowych, flagę możemy znaleźć klikając
"Pokaż źródło strony" w przeglądarce internetowej.

\begin{figure}[ht]
    \centering
    \includegraphics[width=10cm]{flag_page_source}
    \caption{Flaga \textbf{f7s0jkl} ukryta w źródle strony internetowej}
    \label{fig:flag_page_source}
\end{figure}

W tej pracy zaprezentowana będzie jednak grę oparta
wyłącznie o Reverse Engineering (ang. Inżynieria Wsteczna).
Inżynieria wsteczna oprogramowania może odbywać się na różne sposoby.
Może to być przykładowo wykorzystanie tzw. snifferów do analizy protokołów
komunikacyjnych aplikacji internetowej. W tym wypadku będzie ona jednak
zazwyczaj oznaczała proces analizy programu, aby zrozumieć co robi
oraz w jaki sposób. Przedstawione zadania można by też podpiąć do kategorii
eksploitacji binarnej (ang. Binary Exploitation), która w pewny sposób pokrywa
się z zagadnieniami Reverse Engineeringu. Jest to mianowicie proces
wykorzystywania niedoskonałości programów w celu zmuszenia ich do zrobienia
czegoś, czego w normalnej sytuacji nie powinny robić. Te dwie kategorie pokrywają
się ze sobą, ponieważ zazwyczaj nie jest możliwe rozwiązanie zadania z kategorii
eksploitacji binarnej, bez wykorzystania do tego inżynierii wstecznej. \pagebreak

Produktem końcowym będzie zbiór kilku zadań udostępniony na platformie webowej.
Platforma sama w sobie nie jest niczym specjalnym, udostępnia jedynie takie powszechne
funkcjonalności jak rejestracja użytkowników, ranking najlepszych graczy,
pobieranie zadań oraz interfejs umożliwiający wprowadzanie znalezionych
flag. Z tego względu użyta zostanie gotowa platforma CTFd \cite{CTFd}.
Użycie takiego gotowego rozwiązania pozwoli w pełni skupić się na samych zadaniach,
a ominąć takie kwestie jak np. gracze łamiący zabezpieczenia platformy.

\begin{figure}[ht]
    \centering
    \includegraphics[width=10cm]{ctfd}
    \caption{Przykładowe zadanie na stronie demonstracyjnej CTFd}
    \label{fig:ctfd}
\end{figure}

W tej pracy opisany zostanie zarówno proces tworzenia poszczególnych zadań,
jak i przykładowe ich rozwiązania. Użyte zostało słowo "przykładowe", ponieważ
w takiej kategorii jak Binary Exploitation / Reverse Engineering liczba sposobów
na rozwiązanie danego zadania jest ograniczona jedynie przez wyobraźnie uczestnika.
Nie ograniczymy się również do korzystania ciągle z tych samych narzędzi.
Pokazane zostaną różnorodne podejścia do analizy i rozwiązywania wyzwań.
Zadania będą tworzone z zamiarem zachowania rosnącego stopnia trudności.
Na początku uczestnik będzie miał szansę rozwiązać proste zadania,
zachęcające go do dalszej rozgrywki. Finalne zadania powinny stanowić wyzwanie
nawet dla doświadczonych graczy. \pagebreak

\subsection{Dostępne platformy}

Aktualnie istnieje wiele różnych zawodów CTF online.
Jednym z popularniejszych jest \newline picoCTF \cite{picoCTF}.
Można tam wejść kiedykolwiek, zalogować się i zająć się rozwiązywaniem problemów.

\begin{figure}[ht]
    \centering
    \includegraphics[width=15cm]{picoctf}
    \caption{Zadanie z kategorii Forensics na stronie picoCTF}
    \label{fig:picoctf}
\end{figure}

Główną motywacją do napisania tej pracy jest fakt, że strony tego typu często skupiają
się na zadaniach w takich kategoriach jak Forensics czy Web Exploitation.
Mnie natomiast bardzo interesuję temat inżynierii wstecznej i chciałem
przygotować wyzwania oparte o zadania tylko z tej kategorii.

\subsection{Języki programowania i narzędzia}

Zadania będą tworzone w języku C. Jest to powszechnie znany język, który
z wyłączoną zbyt agresywną optymalizacją ze strony kompilatora, generuje
w miarę przewidywalny kod maszynowy. Zaletą tego jest to, że narzędzia
do debugowania, deasemblacji oraz wykonywania innych analiz programów
dobrze radzą sobie z takimi plikami. Dzięki temu język ten
zapewni nam kontrolę nad tym w jakim stopniu graczowi ułatwimy
lub utrudnimy rozgrywkę. W celu zapewnienia większej różnorodności
środowisk korzystać będziemy zarówno z systemu Windows jak i Linux.

Do rozwiązywania zadań posłużymy się różnorodnymi rodzajami narzędzi.
Poczynając od linuksowych programów linii poleceń takich jak \mintinline{bash}{strings}
czy \mintinline{bash}{gdb}, pisania własnych narzędzi w języku \emph{Python},
czy w końcu korzystając z pełnoprawnych narzędzi z interfejsem graficznym takich
jak \emph{Cutter}, czy używana przez NSA \emph{Ghidra}.

\clearpage

\section{\SectionTitleScope}
\label{sec:zakres-funkcjonalnosci}

\subsection{Platforma}

Do interfejsu webowego skorzystamy z gotowej platformy CTFd \cite{CTFd}.
Finalny produkt będzie dostępny pod adresem
\href{https://ctf.szczygiel.dev}{https://ctf.szczygiel.dev}.
Strona postawiona będzie na prywatnym serwerze VPS. Platforma będzie
uruchomiona w środowisku docker \cite{docker},
a wystawiona do świata będzie poprzez serwer Caddy \cite{Caddy},
który w prosty sposób zapewni nam HTTPS, dzięki organizacji Let's Encrypt \cite{lets_encrypt}.

\subsection{Użytkownicy}

Użytkownikiem systemu będzie każda osoba zainteresowana rozwiązywaniem
tego rodzaju zadań. Może to być zarówno ktoś kształcący się lub pracujący
w dziale informatycznym, jak i osoba dla której jest to jedynie hobby.

Wszystkie gotowe zadania zostaną wrzucone na platformę, dzięki czemu
każda zainteresowana osoba będzie mogła spróbować swoich sił.

\clearpage

\subsection{Prezentacja interfejsu użytkownika}

\begin{figure}[ht]
    Pierwsze co zobaczy każdy użytkownik wchodzący na platformę, to strona główna.
    Będzie z niej można przejść do reszty podstron, takich jak logowanie, rejestracja,
    wylogowanie, spis graczy, tabela wyników oraz lista dostępnych zadań.

    \vspace{1cm}

    \centering
    \includegraphics[width=14cm]{szczygiel_dev}
    \caption{Strona głowna platformy CTF}
    \label{fig:szczygiel_dev}
\end{figure}

\begin{figure}[ht]
    Poniżej przedstawiony jest interfejs rejestracji nowego użytkownika.
    Nie będzie to nic skomplikowanego -- wystarczy podać login, email oraz hasło.

    \vspace{1cm}

    \centering
    \includegraphics[width=14cm]{szczygiel_dev_register}
    \caption{Rejestracja nowego użytkownika}
    \label{fig:szczygiel_dev_register}
\end{figure}

\begin{figure}[ht]
    Jeśli użytkownik posiada konto to będzie się mógł na nie zalogować.

    \vspace{1cm}

    \centering
    \includegraphics[width=14cm]{szczygiel_dev_login}
    \caption{Panel logowania dla istniejącego użytkownika}
    \label{fig:szczygiel_dev_login}
\end{figure}

\begin{figure}[ht]
    Będąc zalogowanym, można wybrać zadanie które ma się ochote rozwiązać.

    \vspace{1cm}

    \centering
    \includegraphics[width=14cm]{szczygiel_dev_challenges}
    \caption{Wybór zadania do rozwiązania}
    \label{fig:szczygiel_dev_challenges}
\end{figure}

\begin{figure}[ht]
Po wybraniu interesującego nas zadania, można pobrać dostarczony plik,
    a następnie po rozwiązaniu zadania wprowadzić prawidłową (lub nie) flagę.

    \vspace{1cm}

    \centering
    \includegraphics[width=14cm]{szczygiel_dev_incorrect}
    \caption{Interfejs zadania oraz wprowadzenie nieprawidłowej flagi}
    \label{fig:szczygiel_dev_incorrect}
\end{figure}

\begin{figure}[ht]
    Po wprowadzeniu prawidłowej flagi otrzymamy stosowny komunikat.
    Można również zauważyć, że zadanie w tle zmieniło kolor na zielony.

    \vspace{1cm}

    \centering
    \includegraphics[width=14cm]{szczygiel_dev_correct}
    \caption{Efekt wprowadzenia prawidłowej flagi}
    \label{fig:szczygiel_dev_correct}
\end{figure}

\begin{figure}[ht]
    Dostępna jest również lista zarejestrowanych użytkowników.
    Można wejść w profil każdego użytkownika i zobaczyć jego postępy.

    \vspace{1cm}

    \centering
    \includegraphics[width=14cm]{szczygiel_dev_users}
    \caption{Spis zarejestrowanych użytkowników}
    \label{fig:szczygiel_dev_users}
\end{figure}

\begin{figure}[ht]
Wchodząc na profil użytkownika można zobaczyć o nim różne informacje.
Jest to przede wszystkim rozkład prawidłowych oraz nieprawidłowych
    wprowadzeń flag oraz wykres posiadanych punktów w czasie.
    Na dole widzimy również wszystkie rozwiązane przez użytkownika zadania.

    \vspace{1cm}

    \centering
    \includegraphics[width=14cm]{szczygiel_dev_user_info}
    \caption{Szczegóły postępów konkretnego użytkownika}
    \label{fig:szczygiel_dev_user_info}
\end{figure}

\begin{figure}[ht]
    Każdy użytkownik może również zmienić oraz dodać informację o sobie.
    Będzie mógł zmienić nazwę użytkownika, email, hasło, oraz dodać
    takie szczegóły jak strona internetowa, firma dla której pracuję czy kraj pochodzenia.

    \vspace{1cm}

    \centering
    \includegraphics[width=14cm]{szczygiel_dev_settings}
    \caption{Edycja profilu użytkownika}
    \label{fig:szczygiel_dev_settings}
\end{figure}

\clearpage

\section{\SectionTitleRealizationAspects}
\label{sec:wybrane-aspekty-realizacji}

W tym rozdziale przedstawione zostaną sposoby tworzenia poszczególnych zadań.
Warto dodać również, że zawarte w opisach flagi są przykładowe i w formacie
\emph{AGH\{nazwa-zadania\}}, aby nie wyjawiać prawdziwych flag użytych w rozgrywce.
Przykładowe rozwiązania zadań znajdują się w rozdziale 5 -- \nameref{sec:wyniki-projektu}.

\subsection{Zadanie 100-simple}

Pierwszym zadaniem jest odnalezienie flagi wprost umieszczonej
w pliku wykonywalnym jako ciąg znaków.
Zadanie to służyć ma jako pewnego rodzaju rozgrzewka i powinno być stosunkowo
proste do rozwiązania nawet przez kompletnie początkujących zawodników.
Poniżej przedstawiona uproszczona\footnote{Uproszczona, czyli zawierająca jedynie
najważniejsze fragmenty kodu, pozbawiona sprawdzania błędów, definicji funkcji
pomocniczych, załączania nagłówków itp.} wersja kodu źródłowego.

\begin{minted}{c}
int main()
{
    char input[64];

    printf("Enter the flag: ");
    fgets(input, sizeof(input), stdin);
    input[strlen(input) - 1] = '\0';

    if (strcmp(input, "AGH{100-simple}") == 0) {
        printf("Correct flag!\n");
    } else {
        printf("Incorrect flag!\n");
    }

    return 0;
}
\end{minted}

Jak widać program jedynie co robi, to pobiera wejście od użytkownika, a następnie
porównuje je z zapisaną na stałe w kodzie flagą. Użytkownik po inspekcji skompilowanego
pliku wykonywalnego komendą \mintinline{bash}{strings} powinien szybko zwrócić uwagę na
ciąg znaków wyglądający jak rozwiązanie tego zadania.
\clearpage

\subsection{Zadanie 200-game}

W drugim zadaniu flaga będzie odszyfrowana zaraz po uruchomieniu programu. Zadaniem
użytkownika będzie odnalezienie tej flagi poprzez debugowanie lub modyfikacje
pliku wykonywalnego w celu zmiany zachowania programu.

Sam program będzie działać w graficznym środowisku systemu Windows.
Do obsługi okienek i innych aspektów graficznych wykorzystana została
biblioteka raylib \cite{raylib}.
Poniżej przedstawiony kod programu z pominięciem funkcji \emph{decrypt\_flag}.

\begin{minted}[breaklines]{c}
bool show_flag()
{
    return false;
}

int main()
{
    if (show_flag()) {
        decrypt_flag();
    }

    SetTraceLogLevel(LOG_ERROR);
    InitWindow(460, 40, "200-game");
    SetTargetFPS(60);

    while (!WindowShouldClose()) {
        BeginDrawing();
        ClearBackground(BLACK);

        if (show_flag()) {
            DrawText((const char*)flag, 10, 10, 20, GREEN);
        } else {
            DrawText("You have not unlocked access to the flag!", 10, 10, 20, RED);
        }

        EndDrawing();
    }

    CloseWindow();
    return 0;
}
\end{minted}

Sednem całego zadania jest funkcja \emph{show\_flag}, która kontroluje czy rozwiązanie
ukaże się użytkownikowi oraz czy flaga w ogóle zostanie odszyfrowana.
Jeśli chodzi o samo szyfrowanie flagi, użyte zostało do tego narzędzie\footnote{zerosum0x0: Obfuscated String/Shellcode Generator - Online Tool \url{https://zerosum0x0.blogspot.com/2017/08/obfuscatedencrypted-cc-online-string.html}} 
pozwalające zamienić ciąg znaków na tablice bajtów wraz z algorytmem odszyfrowującym.
Poniżej przedstawiony fragment wyniku działania takiego narzędzia.

\begin{minted}{c}
unsigned char flag[] = {
    0xa6, 0x40, 0x70, 0x2b, 0x6e, 0xed, 0x80,
    0x19, 0x36, 0xe1, 0x8a, 0xcd, 0x98, 0xa2
};

void decrypt_flag()
{
    for (unsigned int m = 0; m < sizeof(flag); ++m) {
        unsigned char c = flag[m];
        c = (c >> 0x1) | (c << 0x7);
        c ^= 0x74;
        c = -c;
        c += 0x3f;

        ...

        c ^= 0xc8;
        c = ~c;
        c = -c;
        c -= 0x51;
        flag[m] = c;
    }
}
\end{minted}

Odszyfrowanie flagi korzystając z kodu zdekompilowanej funkcji \emph{decrypt\_flag} jest możliwe,
jednak użytkownik powinien sobie dużo szybciej poradzić z rozwiązaniem zadania prostszymi
sposobami.
\clearpage

\subsection{Zadanie 300-strcmp}

\subsection{Zadanie 400-decrypt}

\subsection{Zadanie 500-secret-shell}

\subsection{Zadanie 600-custom-vm}

\clearpage

\section{\SectionTitleWorkOrganization}
\label{sec:organizacja-pracy}
\emph{Struktura zespołu (role poszczególnych osób), krótki opis i
    uzasadnienie przyjętej metodyki i/lub kolejności prac, planowane i
    zrealizowane etapy prac ze wskazaniem udziału poszczególnych
    członków zespołu, wykorzystane praktyki i narzędzia w zarządzaniu
    projektem.}

\clearpage

\section{\SectionTitleResults}
\label{sec:wyniki-projektu}

W tym rozdziale przedstawione zostaną przykładowe sposoby rozwiązania poszczególnych zadań.
Podobnie jak w rozdziale opisującym proces tworzenia tych zadań, znalezione
flagi są przykładowe.

\subsection{Zadanie 100-simple}

Po otworzeniu karty z pierwszym zadaniem uczestnik pobiera załączony do niego
plik -- \emph{simple}.
Na początku sprawdza z jakim rodzajem pliku ma do czynienia.

\begin{minted}[breaklines]{text}
$ file simple
simple: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=4bfaf13eb10701fb33b5442a8e17056253509ef1, for GNU/Linux 3.2.0, with debug_info, not stripped
\end{minted}

Jak zauważa, jest to plik wykonywalny dla 64-bitowego systemu Linux.
Uruchamia więc program, aby sprawdzić jego zachowanie.

\begin{minted}{text}
$ ./simple
Enter the flag: test
Incorrect flag!
\end{minted}

Na początku rozwiązywania każdego zadania z kategorii Reverse Engineering, warto
przejrzeć, czy plik wykonywalny nie zawiera jakiś przydatnych ciągów znaków.

\begin{minted}{text}
$ strings simple
/lib64/ld-linux-x86-64.so.2
puts
__stack_chk_fail
...
Enter the flag: 
AGH{100-simple}
Correct flag!
Incorrect flag!
...
\end{minted}

Zauważa ciekawie wyglądający ciąg znaków \emph{AGH\{100-simple\}}.
Uruchamia więc program jeszcze raz, podając mu ten ciąg znaków na wejście.

\begin{minted}{text}
$ ./simple
Enter the flag: AGH{100-simple}
Correct flag!
\end{minted}

Otrzymuje informację, że jest to prawidłowa flaga.
Po wpisaniu go na stronie zadania dowiaduje się, że jest to prawidłowe rozwiązanie.

\subsection{Zadanie 200-game}

Użytkownikowi po pobraniu oraz uruchomieniu załączonego pliku \emph{game.exe} ukazuję
się następujące okienko.

\begin{figure}[H]
    \centering
    \includegraphics{200_not_unlocked}
    \caption{Okienko programu z informacją o braku dostępu do flagi}
    \label{fig:200_not_unlocked}
\end{figure}

Użytkownik otwiera plik wykonywalny w programie IDA\footnote{
Darmowa wersja programu IDA przeznaczona do użytku domowego dostępna do pobrania pod adresem 
\url{https://www.hex-rays.com/products/ida/support/download_freeware}},
aby zapoznać się z działaniem programu.

\begin{figure}[H]
    \centering
    \includegraphics[width=16cm]{200_ida_graph}
    \caption{Widok grafowy w programie IDA przestawiający główną pętle programu}
    \label{fig:200_ida_graph}
\end{figure}

Zauważa on, że wywołanie funkcji o nazwie \emph{\_show\_flag} decyduję o wyborze jednego
z dwóch węzłów wywołania programu. Biorąc pod uwagę nazwę tej funkcji oraz tekst
wyświetlany w prawym węźle (\textit{,,You have not unlocked access to the fla''...}), domyśla
się, że funkcja \emph{\_show\_flag} decyduję o tym czy flaga zostanie wyświetlona użytkownikowi.

\begin{figure}[H]
    \centering
    \includegraphics{200_ida_show_flag}
    \caption{Funkcja \emph{\_show\_flag}}
    \label{fig:200_ida_show_flag}
\end{figure}

Jedyne co ta funkcja robi to zwraca liczbę 0 -- czyli \emph{false}.
Próbuję on więc spatchować\footnote{Patchowanie w tym wypadku oznacza modyfikowanie programu
wykonywalnego poprzez nadpisanie konkretnych bajtów}
program, aby funkcja ta zwracała 1 -- czyli \emph{true}.

\begin{figure}[H]
    \centering
    \includegraphics{200_ida_patch}
    \caption{Modyfikacja instrukcji, aby zwracała 1 zamiast 0}
    \label{fig:200_ida_patch}
\end{figure}

Po zaaplikowaniu patch'a oraz ponownym uruchomieniu programu użytkownikowi ukazuję się
następujący widok.

\begin{figure}[H]
    \centering
    \includegraphics{200_flag}
    \caption{Okienko programu wraz z otrzymaną flagą}
    \label{fig:200_flag}
\end{figure}

Po wpisaniu na stronie flagi \emph{AGH\{200-game\}} użytkownik otrzymuję informację
o poprawnym rozwiązaniu zadania.

\clearpage

\subsection{Zadanie 300-strcmp}

\subsection{Zadanie 400-decrypt}

\subsection{Zadanie 500-secret-shell}

\subsection{Zadanie 600-custom-vm}

\clearpage

\bibliography{bibliography}

\end{document}
