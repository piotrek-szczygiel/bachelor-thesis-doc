\documentclass[language=polish,type=eng]{aghmodern}

\titleEN{Capture-The-Flag game based on reverse engineering}
\titlePL{Gra typu Capture-The-Flag oparta o reverse engineering}
\author{Piotr Szczygieł}
\faculty{Wydział Informatyki, Elektroniki i Telekomunikacji}
\department{Katedra Informatyki}
\supervisor{dr inż. Łukasz Faber}
\degreeprogramme{Informatyka}
\degreetype{Stacjonarne}
\date{2021}

%\usepackage[backend=biber,doi=true,url=false]{biblatex}
%\addbibresource{bibliography.bib}

\usepackage{minted}
\usepackage[toc,page]{appendix}

\renewcommand\appendixtocname{Dodatki}
\renewcommand\appendixpagename{Dodatki}

\graphicspath{ {./images/} }

\begin{document}

\frontmatter
\maketitle
\tableofcontents

\mainmatter

\chapter{Cel prac i wizja produktu}

Gra typu Capture-the-Flag jest to rodzaj zawodów z ogólnie pojętego
bezpieczeństwa komputerowego. Ich celem zwykle jest edukacja uczestników
o zabezpieczeniach systemów oraz możliwość pokazania im jak reagować
na wypadek wystąpienia rzeczywistych ataków. Zawody takie podzielone są zazwyczaj
na poszczególne zadania z różnych kategorii. Aby rozwiązać takie zadanie należy
znaleźć ,,flagę'', którą następnie podaje się w interfejsie udostępnionym przez
organizatora zawodów. Flagą w tym wypadku jest ciąg znaków, który możemy uzyskać
poprzez rozwiązanie zadania. Przykładowo w najprostszych zadaniach
z dziedziny eksploitacji stron internetowych, flagę możemy znaleźć klikając
,,Pokaż źródło strony'' w przeglądarce internetowej.

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{flag_page_source}
\caption{Flaga \emph{f7s0jkl} ukryta w źródle strony internetowej}
\end{figure}

W tej pracy zaprezentowana będzie jednak gra oparta
wyłącznie o inżynierię wsteczną (ang. reverse engineering).
Inżynieria wsteczna oprogramowania może odbywać się na różne sposoby.
Może to być przykładowo wykorzystanie tzw. snifferów do analizy protokołów
komunikacyjnych aplikacji internetowej. W tym wypadku będzie ona jednak
zazwyczaj oznaczała proces analizy programu, aby zrozumieć co robi
oraz w jaki sposób. Przedstawione zadania można by też podpiąć do kategorii
eksploitacji binarnej (ang. binary exploitation), która w pewny sposób pokrywa
się z zagadnieniami inżynierii wstecznej. Jest to mianowicie proces
wykorzystywania niedoskonałości programów w celu zmuszenia ich do zrobienia
czegoś, czego w normalnej sytuacji nie powinny robić. Te dwie kategorie pokrywają
się ze sobą, ponieważ zazwyczaj nie jest możliwe rozwiązanie zadania z kategorii
eksploitacji binarnej, bez wykorzystania do tego inżynierii wstecznej.

Produktem końcowym będzie zbiór kilku zadań udostępniony na platformie webowej.
Platforma sama w sobie nie jest niczym specjalnym, udostępnia jedynie takie powszechne
funkcjonalności jak rejestracja użytkowników, ranking najlepszych graczy,
pobieranie zadań oraz interfejs umożliwiający wprowadzanie znalezionych
flag. Użyta zostanie gotowa platforma, aby w pełni skupić się na samych zadaniach,
a ominąć takie kwestie jak np. gracze łamiący zabezpieczenia platformy.

W tej pracy opisany zostanie zarówno proces tworzenia poszczególnych zadań,
jak i przykładowe ich rozwiązania. Użyte zostało słowo ,,przykładowe'', ponieważ
w takiej kategorii jak Binary Exploitation lub Reverse Engineering liczba sposobów
na rozwiązanie danego zadania jest ograniczona jedynie przez wyobraźnie uczestnika.
Nie ograniczymy się również do korzystania ciągle z tych samych narzędzi.
Pokazane zostaną różnorodne podejścia do analizy i rozwiązywania wyzwań.
Zadania będą tworzone z zamiarem zachowania rosnącego stopnia trudności.
Na początku uczestnik będzie miał szansę rozwiązać proste zadania,
zachęcające go do dalszej rozgrywki. Finalne zadania powinny stanowić wyzwanie
nawet dla doświadczonych graczy.

\section{Motywacja}

Aktualnie istnieje wiele różnych zawodów CTF online. Jednym z popularniejszych
jest \mbox{picoCTF}\footnote{\url{https://picoctf.com/}}.
Można tam wejść kiedykolwiek, zalogować się i zająć się rozwiązywaniem problemów.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{picoctf}
\caption{Zadanie z kategorii Forensics na stronie picoCTF}
\end{figure}

Główną motywacją do napisania tej pracy jest fakt, że strony tego typu często skupiają
się na zadaniach w takich kategoriach jak Forensics czy Web Exploitation.
Brakuje natomiast platform z zadaniami typowo o tematyce inżynierii
wstecznej, na której skupi się ta praca.

\section{Studium wykonalności}

Zadania CTF mogą być tworzone z wykorzystaniem różnych technologii.
Jeśli chodzi jednak konkretnie o zadania z kategorii inżynierii wstecznej
nie ma dużego wyboru -- musimy wybrać niskopoziomowy kompilowany język.

\subsection{Język programowania i narzędzia}

Zadania będą tworzone w języku C. Jest to powszechnie znany język, który
z wyłączoną zbyt agresywną optymalizacją ze strony kompilatora, generuje
w miarę przewidywalny kod maszynowy. Zaletą tego jest to, że narzędzia
do debugowania, deasemblacji oraz wykonywania innych analiz programów
dobrze radzą sobie z takimi plikami. Dzięki temu język ten
zapewni nam kontrolę nad tym w jakim stopniu graczowi ułatwimy
lub utrudnimy rozgrywkę. W celu zapewnienia większej różnorodności
środowisk korzystać będziemy zarówno z systemu Windows jak i Linux.

Do rozwiązywania zadań posłużymy się różnorodnymi rodzajami narzędzi.
Poczynając od linuksowych programów linii poleceń takich jak \mintinline{bash}{strings}
czy \mintinline{bash}{gdb}, pisania własnych narzędzi w języku \emph{Python},
czy w końcu korzystając z pełnoprawnych narzędzi z interfejsem graficznym takich
jak \emph{Cutter}, czy używana przez NSA \emph{Ghidra}.

\chapter{Zakres funkcjonalności}

\section{Użytkownicy}

Użytkownikiem systemu będzie każda osoba zainteresowana rozwiązywaniem
tego rodzaju zadań. Może to być zarówno ktoś kształcący się lub pracujący
w dziale informatycznym, jak i osoba dla której jest to jedynie hobby.

Wszystkie gotowe zadania zostaną wrzucone na platformę, dzięki czemu
każda zainteresowana osoba będzie mogła spróbować swoich sił.

\section{Wymagania funkcjonalne}

Każde z zadań będzie sprawdzało różne umiejętności rozwiązujących je użytkowników.
Kolejne zadania będą miały coraz większy stopień trudności. Liczba przy nazwie zadania
oznacza ilość punktów, które użytkownik dostanie za prawidłowe rozwiązanie.
Poniżej przedstawione są zadania wraz z umiejętnościami użytkownika,
które przetestują. Stworzonych zostało sześć zadań, ponieważ tyle wystarczyło
aby przedstawić różnorodne metody inżynierii wstecznej.

\subsection{100-simple}
\begin{itemize}
    \item Podstawowa znajomość konstrukcji i działania plików wykonywalnych
    \item Umiejętność korzystania z narzędzi do poglądu zawartości plików binarnych
    (np. edytor heksadecymalny lub program \mintinline{text}{strings})
\end{itemize}

\subsection{200-game}

\begin{itemize}
    \item Obsługa deasemblerów x86
    \item Podstawowa znajomość języka Asembler x86
    \item Obsługa narzędzi do patchowania plików wykonywalnych
\end{itemize}

\subsection{300-strcmp}

\begin{itemize}
    \item Znajomość sposobów wywoływania funkcji -- ABI\footnote{
    \url{https://pl.wikipedia.org/wiki/Interfejs_binarny_aplikacji}}
    \item Obsługa narzędzi do debugowania programów bez kodu źródłowego
\end{itemize}

\subsection{400-decrypt}

\begin{itemize}
    \item Obsługa narzędzi dekompilujących pliki wykonywalne jak np. IDA, Ghidra
    \item Umiejętność czytania i analizy zdekompilowanego pseudokodu
    \item Znajomość dowolnego języka (np. Python) wspomagającego rozwiązywanie zadań CTF
\end{itemize}

\subsection{500-secret-shell}

\begin{itemize}
    \item Działanie systemu Linux, m.in. uprawnienia i atrybut setuid
    \item Znajomość konstrukcji ramki stosu w programie
    \item Podstawowa znajomość ataków przepełnienia bufora z nadpisaniem adresu powrotu funkcji
\end{itemize}

\subsection{600-vm}

\begin{itemize}
    \item Znajomość działania procesorów i maszyn wirtualnych
    \item Umiejętność napisania prostego deasemblera
    \item Czytanie kodu w nieznanym wcześniej języku
\end{itemize}

\section{Wymagania niefunkcjonalne}

\subsection{Prostota wdrożenia platformy}

Wdrożenie platformy powinno być możliwe poprzez uruchomienie gotowego
dockerowego kontenera, a przekazanie plików do zadań dostępne w łatwy sposób
poprzez interfejs platformy.

\subsection{Możliwość logowania i rejestracji użytkowników}

Użytkownicy powinni mieć możliwość utworzenia konta w celu
śledzenia swojego postępu w rozwiązywaniu zadań.

\subsection{Możliwość administrowania platformy}

Platforma powinna udostępniać panel administratora na którym
można zarządzać użytkownikami i podglądać statystyki rozwiązywanych
zadań.

\chapter{Wybrane aspekty realizacji}

W tym rozdziale przedstawiona zostanie wybrana platforma oraz
sposoby tworzenia poszczególnych zadań.
Warto dodać również, że przestawione flagi są w formacie \emph{AGH\{nazwa-zadania\}},
aby nie wyjawiać prawdziwych flag użytych w rozgrywce.
Przykładowe rozwiązania zadań znajdują się w dodatku \nameref{chap:writeups}.

\section{Platforma}

Do przeglądarkowego interfejsu użytkownika skorzystamy z gotowej
platformy CTFd\footnote{\url{https://ctfd.io/}}.
Finalny produkt będzie dostępny pod adresem \url{https://ctf.szczygiel.dev/}.
Strona postawiona będzie na prywatnym serwerze VPS. Platforma będzie
uruchomiona w środowisku Docker, a wystawiona do świata będzie poprzez serwer
Caddy\footnote{\url{https://caddyserver.com/}}, który w prosty sposób zapewni nam HTTPS,
dzięki organizacji Let's Encrypt\footnote{\url{https://letsencrypt.org/}}.
Platformę uruchamia się jedynie poleceniem \mintinline{text}{docker-compose up},
a jedyną konfiguracją serwera Caddy jest ustawienie odwrotnego
pośrednika (ang. reverse proxy) z wystawionego przez kontener portu \emph{8000}.

\begin{figure}[H]
\centering
\includegraphics[width=8cm]{ctfd}
\caption{Przykładowe zadanie na stronie demonstracyjnej CTFd}
\end{figure}

\section{Zadanie 100-simple}

Pierwszym zadaniem jest odnalezienie flagi wprost umieszczonej
w pliku wykonywalnym jako ciąg znaków.
Zadanie to służyć ma jako pewnego rodzaju rozgrzewka i powinno być stosunkowo
proste do rozwiązania nawet przez kompletnie początkujących zawodników.
Poniżej uproszczony\footnote{Uproszczony, czyli zawierający jedynie
najważniejsze fragmenty kodu, pozbawiony sprawdzania błędów, definicji funkcji
pomocniczych, załączania nagłówków itp.} kod programu.

\begin{minted}{c}
int main()
{
    char input[64];

    printf("Enter the flag: ");
    fgets(input, sizeof(input), stdin);

    input[strlen(input) - 1] = '\0';

    if (strcmp(input, "AGH{100-simple}") == 0) {
        puts("Correct flag!");
    } else {
        puts("Incorrect flag!");
    }

    return 0;
}
\end{minted}

Jak widać program jedynie co robi, to pobiera wejście od użytkownika, a następnie
porównuje je z zapisaną na stałe w kodzie flagą. Użytkownik po inspekcji skompilowanego
pliku wykonywalnego komendą \mintinline{bash}{strings} lub użyciu innego narzędzia
do inspekcji plików binarnych, powinien szybko zwrócić uwagę na
ciąg znaków wyglądający jak rozwiązanie tego zadania.

\section{Zadanie 200-game}

W drugim zadaniu flaga będzie odszyfrowana zaraz po uruchomieniu programu. Zadaniem
użytkownika będzie odnalezienie tej flagi poprzez modyfikacje
pliku wykonywalnego w celu zmiany zachowania programu.

Sam program będzie działać w graficznym środowisku systemu Windows.
Do obsługi okienek i innych aspektów graficznych wykorzystana została
biblioteka raylib\footnote{\url{https://www.raylib.com/}}.
Poniżej przedstawiony kod programu z pominięciem funkcji \emph{decrypt\_flag}.

\begin{minted}[breaklines]{c}
bool show_flag()
{
    return false;
}

int main()
{
    if (show_flag()) {
        decrypt_flag();
    }

    SetTraceLogLevel(LOG_ERROR);
    InitWindow(460, 40, "200-game");
    SetTargetFPS(60);

    while (!WindowShouldClose()) {
        BeginDrawing();
        ClearBackground(BLACK);

        if (show_flag()) {
            DrawText((const char*)flag, 10, 10, 20, GREEN);
        } else {
            DrawText("You have not unlocked access to the flag!", 10, 10, 20, RED);
        }

        EndDrawing();
    }

    CloseWindow();
    return 0;
}
\end{minted}

Sednem całego zadania jest funkcja \emph{show\_flag}, która kontroluje czy rozwiązanie
ukaże się użytkownikowi oraz czy flaga w ogóle zostanie odszyfrowana.
Jeśli chodzi o samo szyfrowanie flagi, użyte zostało do tego narzędzie\footnote{
zerosum0x0: Obfuscated String/Shellcode Generator - Online Tool
\url{https://zerosum0x0.blogspot.com/2017/08/obfuscatedencrypted-cc-online-string.html}}
pozwalające zamienić ciąg znaków na tablice bajtów wraz z algorytmem odszyfrowującym.
Poniżej przedstawiony fragment wyniku działania takiego narzędzia.

\begin{minted}{c}
unsigned char flag[] = {
    0xa6, 0x40, 0x70, 0x2b, 0x6e, 0xed, 0x80,
    0x19, 0x36, 0xe1, 0x8a, 0xcd, 0x98, 0xa2
};

void decrypt_flag()
{
    for (unsigned int m = 0; m < sizeof(flag); ++m) {
        unsigned char c = flag[m];
        c = (c >> 0x1) | (c << 0x7);
        c ^= 0x74;
        c = -c;
        c += 0x3f;

        ...

        c ^= 0xc8;
        c = ~c;
        c = -c;
        c -= 0x51;
        flag[m] = c;
    }
}
\end{minted}

Odszyfrowanie flagi korzystając z kodu zdekompilowanej funkcji \emph{decrypt\_flag} jest możliwe,
jednak użytkownik powinien sobie dużo szybciej poradzić z rozwiązaniem zadania prostszymi
sposobami.

\section{Zadanie 300-strcmp}

Trzecie zadanie będzie połączeniem dwóch wcześniejszych.
Poniżej przedstawiona funkcja \emph{main} programu.

\begin{minted}[breaklines]{c}
int main()
{
    decrypt_flag();

    char input[64];

    printf("Enter the flag: ");
    fgets(input, sizeof(input), stdin);

    input[strlen(input) - 1] = '\0';

    if (strcmp(input, (char*)flag) == 0) {
        puts("Correct flag!");
    } else {
        puts("Incorrect flag!");
    }

    return 0;
}
\end{minted}

Jak widać kod jest taki sam jak w zadaniu pierwszym, jedynie z tą różnicą, że
flaga zamiast zapisana w kodzie w jawny sposób, jest odszyfrowywana zaraz po uruchomieniu
programu -- podobnie jak w zadaniu drugim.

\section{Zadanie 400-decrypt}

Czwarte zadanie będzie zawierało funkcje szyfrującą wejście użytkownika, a następnie to wejście będzie
porównywane z wcześniej zaszyfrowaną flagą. Zadaniem użytkownika będzie przykładowo napisanie skryptu
odwracającego działanie funkcji szyfrującej i uruchomienie go podając na wejście zaszyfrowaną flagę
wyciągniętą z pliku wykonywalnego.

Funkcja szyfrującą będzie dzieliła się na dwa etapy. Pierwszym etapem będzie użycie prostego
szyfru Cezara z przesunięciem 13 -- zwanym także ROT13. Drugi etap będzie to prosty szyfr XOR
z użyciem 4 bajtowego klucza. Poniżej przestawiony kod funkcji \emph{main} programu.

\begin{minted}[breaklines]{c}
int main()
{
    char input[64];

    printf("Enter the flag: ");
    fgets(input, sizeof(input), stdin);

    int length = strlen(input) - 1;
    input[length] = '\0';

    if (length == sizeof(flag)) {
        encrypt(input, length);

        if (memcmp(input, flag, length) == 0) {
            puts("Correct flag!");
            return 0;
        }
    }

    puts("Incorrect flag!");
    return 0;
}
\end{minted}

Jak widać główny kod programu jest bardzo prosty i nie różni się specjalnie od poprzednich zadań.
Poniżej przedstawiona zostanie funkcja szyfrująca \emph{encrypt}.

\begin{minted}{c}
void encrypt(char* input, int length)
{
    for (int i = 0; i < length; ++i) {
        char c = input[i];

        if (c >= 'A' && c <= 'Z') {
            if (c + 13 <= 'Z')
                input[i] = c + 13;
            else
                input[i] = c - 13;
        } else if (c >= 'a' && c <= 'z') {
            if (c + 13 <= 'z')
                input[i] = c + 13;
            else
                input[i] = c - 13;
        }
    }

    char key[] = { 0xde, 0xad, 0xbe, 0xef };
    int k = 0;

    for (int i = 0; i < length; ++i) {
        input[i] ^= key[k];
        k = (k + 1) % sizeof(key);
    }
}
\end{minted}

Pierwsza część szyfrowania, czyli ROT13, przechodzi po kolei po każdym znaku na wejściu i jeśli jest to litera,
to przesuwa ją o 13 w lewo albo 13 w prawo. Druga część to prosty szyfr XOR z kluczem \emph{0xde, 0xad, 0xbe, 0xef}.
Program przechodzi po kolei po każdym znaku i wykonuje operacje XOR z kolejnymi bajtami klucza. Jeśli dojdziemy
do ostatniego bajta klucza -- wracamy z powrotem do pierwszego bajtu.

Ostatnim krokiem jest wygenerowanie tablicy \emph{flag}. Tworzymy nowy pomocniczy program
-- \emph{generate}, zawierający zmodyfikowaną funkcję \emph{main},
która zwróci nam finalną zawartość tablicy \emph{flag}.
Poniżej przestawiony zmodyfikowany kod funkcji \emph{main} dla programu \emph{generate}.

\begin{minted}{c}
int main()
{
    char input[64];
    fgets(input, sizeof(input), stdin);

    int length = strlen(input) - 1;
    input[length] = '\0';

    encrypt(input, length);

    for (int i = 0; i < length; ++i) {
        printf("0x%02x, ", (unsigned char)input[i]);
    }

    return 0;
}
\end{minted}

Kompilujemy i uruchamiamy program, podając mu na wejście flagę, którą użytkownik będzie musiał odgadnąć.

\begin{minted}[breaklines]{text}
$ make generate
gcc -Wall -Wextra -std=c99 generate.c -o generate
$ ./generate
AGH{400-decrypt}
0x90, 0xf9, 0xeb, 0x94, 0xea, 0x9d, 0x8e, 0xc2, 0xaf, 0xdf, 0xce, 0x8a, 0xb2, 0xce, 0xd9, 0x92,
\end{minted}

Teraz możemy do głównego programu dodać definicje tablicy \emph{flag}.

\begin{minted}[breaklines]{c}
char flag[] = { 0x90, 0xf9, 0xeb, 0x94, 0xea, 0x9d, 0x8e, 0xc2, 0xaf, 0xdf, 0xce, 0x8a, 0xb2, 0xce, 0xd9, 0x92 };
\end{minted}

\section{Zadanie 500-secret-shell}

Piąte zadanie będzie różnić się od pozostałych tym, że program będzie uruchamiany
na zdalnym hoście i dostępny poprzez SSH. Na tym hoście utworzonych będzie dwóch użytkowników.
Jednym z nich będzie użytkownik \emph{ctf} do którego dostęp będzie miał uczestnik rozwiązujący
to zadanie. Drugim użytkownikiem będzie \emph{admin}, który będzie właścicielem pliku
wykonywalnego \emph{secret-shell} oraz pliku zawierającego flagę \emph{access\_code.txt}.
Użytkownik \emph{ctf} nie będzie posiadał praw odczytu do pliku z flagą, więc będzie
musiał znaleźć jakiś sposób, aby te prawa uzyskać. Umożliwimy mu to tworząc podatny
na atak Stack Buffer Overflow\footnote{
\url{https://en.wikipedia.org/wiki/Stack_buffer_overflow}} program z ustawioną flagą SUID\footnote{
\url{https://en.wikipedia.org/wiki/Setuid\#When_set_on_an_executable_file}}.
Oznacza to, że mimo tego, że program będzie uruchamiał użytkownik \emph{ctf}, to będzie on
działał z prawami użytkownika \emph{admin}.

Poniżej przedstawiony uproszczony kod głównej funkcji programu \emph{secret-shell}.

\begin{minted}{c}
int main()
{
    gid_t gid = getegid();
    uid_t uid = geteuid();
    setresgid(gid, gid, gid);
    setresuid(uid, uid, uid);

    greeter();

    char access_code[64];
    FILE* file = fopen("/home/admin/access_code.txt", "r");
    fgets(access_code, sizeof(access_code), file);
    fclose(file);

    char input[64];

    while (true) {
        printf("Enter the access code: ");
        fgets(input, sizeof(input), stdin);

        if (strcmp(access_code, input) == 0) {
            puts("Access granted!");
            access_secret_shell();
            break;
        } else {
            puts("Access denied!");
            printf("\n\n");
        }
    }

    return 0;
}
\end{minted}

Na początku ustawiamy, aby program działał z uprawnieniami użytkownika \emph{admin}.
Zapewnione to będzie przez ustawienie flagi SUID na pliku wykonywalnym.
Następnie wywołujemy funkcje \emph{greeter}, wczytujemy flagę do zmiennej i przechodzimy
do głównej pętli. Pobiera ona kod dostępu do użytkownika, sprawdza go z prawidłowym kodem,
a następnie przenosi go do funkcji \emph{access\_secret\_shell} lub informuje o
nieprawidłowym kodzie i przenosi się na początek pętli.

Poniżej przedstawione są uproszczone funkcje \emph{access\_secret\_shell} oraz \emph{greeter}.

\begin{minted}{c}
void access_secret_shell()
{
    puts("Welcome to secret shell!");
    system("/bin/sh");
    puts("Exiting secret shell...");
}

void greeter()
{
    char name[64];

    printf("Welcome, enter your name: ");
    gets(name);
    printf("Hello, %s\n\n", name);
}
\end{minted}

Jak widać funkcja \emph{access\_secret\_shell} jedynie uruchamia program \mintinline{text}{/bin/sh}.
Z racji tego, że program jest uruchomiony z uprawnieniami \emph{admin}, będzie możliwe
wyświetlenie flagi np. programem \mintinline{text}{cat}.
Funkcja \emph{greeter} natomiast pobiera od użytkownika imię oraz je wyświetla.
Pobiera je jednak niebezpieczną funkcją \emph{gets}, która jest podatna na ataki
przepełnienia bufora -- nie sprawdza ona bowiem długości bufora do którego zapisuje dane i wpisuje
je nawet po osiągnięciu jego końca.

Plik źródłowy skompilowany będzie następującym poleceniem:

\begin{minted}[breaklines]{text}
$ gcc -std=c99 -m32 -fno-stack-protector -no-pie -fno-pic secret-shell.c -o secret-shell
\end{minted}

Flaga \mintinline{text}{-m32} zapewni, że program będzie 32-bitowy,
\mintinline{text}{-fno-stack-protector} wyłączy Stack Canary\footnote{
\url{https://en.wikipedia.org/wiki/Buffer_overflow_protection\#Canaries}},
natomiast \emph{-no-pie -fno-pic} spowodują, że adresy funckji nie będą się zmieniać
pomiędzy kolejnymi uruchomieniami. Żeby to jednak zapewnić trzeba również wyłączyć
ASLR\footnote{\url{https://en.wikipedia.org/wiki/Address_space_layout_randomization}}
na serwerze SSH następującym poleceniem.

\begin{minted}{text}
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
\end{minted}

Żeby nie ryzykować działania hosta na którym postawiony będzie serwer SSH wszystko
będzie uruchomione w kontenerze za pomocą narzędzia Docker\footnote{
\url{https://www.docker.com/}}. Poniżej przedstawiony przepis stawiania kontenera, czyli
plik \emph{Dockerfile}.

\begin{minted}[breaklines]{docker}
FROM ubuntu:20.04

RUN dpkg --add-architecture i386 \
    && apt-get update \
    && apt-get install -y libc6:i386 libncurses5:i386 libstdc++6:i386 openssh-server binutils python2 vim \
    && useradd -m admin \
    && useradd -s /bin/bash ctf \
    && echo "ctf:agh-reverse-engineering" | chpasswd \
    && mkdir -p /var/run/sshd

COPY secret-shell /home/admin/secret-shell
COPY decrypted_flag.txt /home/admin/access_code.txt

RUN chown admin:admin /home/admin/secret-shell /home/admin/access_code.txt \
    && chmod 4755 /home/admin/secret-shell \
    && chmod 600 /home/admin/access_code.txt

EXPOSE 22
CMD ["/usr/sbin/sshd", "-D"]
\end{minted}

Kontener będzie postawiony na systemie Linux Ubuntu 20.04\footnote{\url{https://ubuntu.com/}}.
Po zainstalowaniu potrzebnych aplikacji, dodajemy użytkownika \emph{admin} oraz użytkownika
\emph{ctf} z hasłem \emph{agh-reverse-engineering}. Kopiujemy skompilowany wcześniej
program \emph{secret-shell} oraz plik tekstowy z jawnie zapisaną flagą do pliku
\emph{access\_code.txt}. Następnie ustawiamy odpowiednie uprawnienia, w tym bit SUID
dla programu \emph{secret\_shell} i na koniec uruchamiamy serwer SSH.
Kontener ten możemy teraz zbudować i uruchomić następującymi poleceniami.

\begin{minted}{text}
$ docker build -t secret-shell .
$ docker run -d -p 2222:22 secret-shell
\end{minted}

Przekierowujemy zewnętrzny port 2222 do wewnętrznego portu kontenera 22, aby użytkownik
miał dostęp do serwera SSH zarówno komputera hosta jak i kontenera.

\section{Zadanie 600-vm}

W szóstym i zarazem ostatnim zadaniu stworzymy prostą maszynę wirtualną, a dokładniej
interpreter wymyślonego przez nas kodu bajtowego. Następnie napiszemy program sprawdzający
poprawność flagi, który będzie uruchamiany wewnątrz tej maszyny. Zacznijmy od działania
samego interpretera.

\begin{minted}{c}
// Generated header file containing ROM char array
#include "ctf.h"

#define MEMORY_SIZE 0x7fff
#define MEMORY_ORIGIN 0x1337
#define STACK_SIZE 0x0100
#define INPUT_SIZE 128

typedef struct VM {
    uint8_t mem[MEMORY_SIZE];
    uint8_t* ip;

    short stack[STACK_SIZE];
    short* sp;

    uint8_t input[INPUT_SIZE];
    uint8_t* input_ptr;
} VM;
\end{minted}

Stan naszej maszyny będzie przechowywany w strukturze \emph{VM}. Zawiera ona kilka zmiennych
potrzebnych do jej prawidłowego działania. Tablica \emph{mem} będzie zawierała pamięć operacyjną --
wczytywany będzie do niej program. Wskaźnik \emph{ip}, czyli licznik progrmau (ang. instruction pointer)
wskazywać będzie na adres aktualnie wykonywanej instrukcji -- odpowiednik rejestru \emph{EIP}
w 32 bitowych procesorach x86. Warto też dodać, że nasza maszyna będzie maszyną stosową
-- operacje będą wykonywane na stosie i nie będzie ona posiadać rejestrów pomocniczych.
Łatwo się więc domyślić, że tablica \emph{stack} oraz wskaźnik \emph{sp}
to stos oraz wskaźnik na jego ostatni element. Na koniec jest tablica \emph{input},
która będzie przechowywać flagę wprowadzoną przez użytkownika po uruchomieniu programu.
Zamiast tego moglibyśmy ładować wejście użytkownika pod wcześniej ustalonym adresem pamięci
operacyjnej, ale taki sposób jest czytelniejszy. Wskaźnik \emph{input\_ptr} będzie wskazywać
na początku na pierwszy znak wejścia użytkownika. Dodamy do maszyny instrukcję, która będzie ten
znak wrzucać na stos i przesuwać wskaźnik na kolejny znak. Dzięki temu wykonywany na maszynie
program będzie miał dostęp do wejścia użytkownika znak po znaku w prosty sposób.
Zapoznajmy się teraz z funkcjami inicjalizującymi maszynę.

\begin{minted}{c}
void vm_init(VM* vm)
{
    vm->ip = vm->mem + MEMORY_ORIGIN;
    vm->sp = vm->stack;
    vm->input_ptr = vm->input;
}

void vm_load(VM* vm, const uint8_t* rom, size_t rom_size)
{
    memcpy(vm->mem + MEMORY_ORIGIN, rom, rom_size);
}
\end{minted}

Funkcja \emph{vm\_init} ustawia licznik programu na tablice pamięci operacyjnej powiększoną o stałą
\emph{MEMORY\_ORIGIN}. W to samo miejsce potem funkcja \emph{vm\_load} wczyta program. Sama stała
\emph{MEMORY\_ORIGIN} nie ma większego znaczenia i ma na celu jedynie minimalne utrudnienie użytkownikowi
śledzenie adresów instrukcji. Następnie funkcja \emph{vm\_init} ustawia wskaźnik stosu na jego początek
oraz wskaźnik wejścia na początek tablicy \emph{input}.

Zanim przejdziemy do opisu instrukcji oraz interpretera zapoznajmy się z kilkoma funkcjami pomocniczymi.
Przedstawiony kod będzie pozbawiony sprawdzania błędów.

\begin{minted}{c}
void vm_push(VM* vm, short value)
{
    *vm->sp++ = value;
}

short vm_pop(VM* vm)
{
    return *--vm->sp;
}

void vm_fill_input(VM* vm, const char* input, int size)
{
    memcpy(vm->input, input, size);
}

uint8_t vm_read_byte(VM* vm)
{
    return *vm->ip++;
}

short vm_read_short(VM* vm)
{
    vm->ip += 2;
    return *(vm->ip - 2) | *(vm->ip - 1) << 8;
}
\end{minted}

Funkcje \emph{vm\_push} oraz \emph{vm\_pop} kolejno wrzucają oraz ściągają liczbę typu \emph{short} ze stosu.
Funkcja \emph{vm\_fill\_input} kopiuje wejście użytkownika do tablicy \emph{vm->input}.
Funkcje \emph{vm\_read\_byte} oraz \emph{vm\_read\_short} czytają kolejno jedno lub dwubajtową liczbę
na która wskazuję licznik programu, a następnie przesuwają ten licznik na kolejną instrukcję.
Przechodzimy teraz do głównej funkcji czyli \emph{vm\_run}.

\begin{minted}{c}
int vm_run(VM* vm)
{
    for (;;) {
        uint8_t opcode = vm_read_byte(vm);

        switch (opcode) {
\end{minted}

Funkcja ta w nieskończonej pętli wczytuje bajt, po czym wykonuje odpowiednią instrukcję.
Przejdziemy teraz po kolei po każdym obsługiwanym kodzie operacji.

\begin{minted}{c}
        case OP_HALT: {
            short value = vm_read_short(vm);
            return value;
        }
\end{minted}

Instrukcja \emph{OP\_HALT} kończy działanie maszyny z podanym kodem statusu.

\begin{minted}{c}
        case OP_PUSH: {
            short value = vm_read_short(vm);
            vm_push(vm, value);
            break;
        }
\end{minted}

Instrukcja \emph{OP\_PUSH} wrzuca podaną liczbę na stos.

\begin{minted}{c}
        case OP_POP: {
            vm_pop(vm);
            break;
        }
\end{minted}

Instrukcja \emph{OP\_POP} ściąga liczbę ze stosu.

\begin{minted}{c}
        case OP_XOR: {
            short a = vm_pop(vm);
            short b = vm_pop(vm);
            short result = a ^ b;
            vm_push(vm, result);
            break;
        }
\end{minted}

Instrukcja \emph{OP\_XOR} ściąga dwie liczby ze stosu, a następnie wrzuca na stos wynik
operacji XOR na tych liczbach.

\begin{minted}{c}
        case OP_MUL: {
            short a = vm_pop(vm);
            short b = vm_pop(vm);
            short result = a * b;
            vm_push(vm, result);
            break;
        }
\end{minted}

Instrukcja \emph{OP\_MUL} ściąga dwie liczby ze stosu, a następnie wrzuca na stos ich iloczyn.

\begin{minted}{c}
        case OP_INP: {
            if (vm->input_ptr - vm->input >= INPUT_SIZE) {
                exit(6);
            }
            uint8_t inp = *vm->input_ptr++;
            vm_push(vm, inp);
            break;
        }
\end{minted}

Instrukcja \emph{OP\_INP} wrzuca na stos kolejny znak z bufora \emph{vm->input}.

\begin{minted}{c}
        case OP_JZ: {
            short jmp = vm_read_short(vm);
            if (vm_pop(vm) == 0) {
                vm->ip = vm->mem + jmp;
            }
            break;
        }
\end{minted}

Instrukcja \emph{OP\_JZ} ściąga liczbę ze stosu i jeśli jest ona równa 0 to przenosi
działanie programu pod zadany adres.

\begin{minted}{c}
        case OP_DUP: {
            short value = vm_pop(vm);
            vm_push(vm, value);
            vm_push(vm, value);
            break;
        }
\end{minted}

Instrukcja \emph{OP\_DUP} duplikuje ostatnią liczbę na stosie.

\begin{minted}{c}
        case OP_INC: {
            short value = vm_pop(vm);
            short result = value + 1;
            vm_push(vm, result);
            break;
        }
\end{minted}

Instrukcja \emph{OP\_INC} dodaje 1 do ostatniej liczby na stosie.

\begin{minted}{c}
        case OP_JEMP: {
            short jmp = vm_read_short(vm);
            if (vm->stack == vm->sp) {
                vm->ip = vm->mem + jmp;
            }
            break;
        }
\end{minted}

Instrukcja \emph{OP\_JEMP} przenosi działanie programu pod wskazany adres jeśli stos jest pusty.

\begin{minted}{c}
        default: {
            exit(2);
        }
\end{minted}

Jeśli nie uda się dopasować żadnej instrukcji, to maszyna się wyłączy.
Musimy jeszcze zdefiniować kod bajtowy dla każdej instrukcji.
Przypisane one zostały losowo.

\begin{minted}{c}
typedef enum Opcode {
    OP_HALT = 225,
    OP_PUSH = 164,
    OP_POP = 155,
    OP_XOR = 3,
    OP_MUL = 162,
    OP_INP = 177,
    OP_JZ = 82,
    OP_DUP = 206,
    OP_INC = 102,
    OP_JEMP = 223,
} Opcode;
\end{minted}

Na koniec zostaje jeszcze funkcja \emph{main}, która pobiera flagę od użytkownika,
uruchamia maszynę wirtualną i sprawdza jej kod wyjścia (program uruchamiany na maszynie,
będzie zwracał 0, jeśli flaga będzie prawidłowa).

\begin{minted}{c}
VM vm;
int main()
{
    vm_init(&vm);
    vm_load(&vm, ctf_rom, ctf_rom_len);

    char flag[INPUT_SIZE];

    printf("Enter the flag: ");
    fgets(flag, sizeof(flag), stdin);

    flag[strlen(flag) - 1] = '\0';
    vm_fill_input(&vm, flag, strlen(flag));

    int result = vm_run(&vm);

    if (result == 0) {
        puts("Correct flag!");
    } else {
        puts("Incorrect flag!");
    }

    return result;
}
\end{minted}

Kiedy mamy gotową maszynę wirtualną musimy teraz napisać program, który na niej
uruchomimy. Program napiszemy korzystając z narzędzia Netwide Assembler\footnote{
\url{http://www.nasm.us/}}. Stworzymy najpierw specjalny plik \emph{vm.inc}, który
zdefiniuje instrukcje dla maszyny i ułatwi nam napisanie programu. Poniżej
przedstawiony fragment tego pliku.

\begin{minted}{nasm}
[org 0x1337]

%macro push 1
db 164
dw %1
%endmacro

%macro pop 0
db 155
%endmacro
\end{minted}

Zawiera on definicje makr o nazwie takiej jak zdefiniowane przez maszynę instrukcje.
Makra mogą również przyjmować argumenty (ilość przyjmowanych argumentów znajduję się
obok nazwy makra), jak np makro \emph{push}. Polecenie \emph{db} oznacza wyemitowanie bajtu,
natomiast \emph{dw} oznacza wyemitowanie słowa (czyli dwóch bajtów). W pierwszej linijce
ustawiamy początek adresacji na \emph{0x1337} tak samo jak w kodzie źródłowym
maszyny wirtualnej. Z takim plikiem definicji możemy przystąpić do pisania programu
sprawdzającego poprawność flagi. Działanie programu zostało przedstawione w rozdziale piątym
na następujących rysunkach: \nameref{fig:600_flowchart} oraz \nameref{fig:600_stack}.
Możemy teraz przystąpić do pisania kodu programu w pliku \emph{ctf.nasm}.

\begin{minted}{nasm}
%include "vm.inc"
%include "ctf.push"

; Validation loop
check_loop:
inp
dup
jz maybe
mul
xor
inc
jz check_loop

; Invalid character
bad:
halt 1

; All checked characters valid, but maybe not long enough
maybe:
pop
jemp good
halt 1

; All characters valid, and length is the same
good:
halt 0
\end{minted}

Potrzebujemy jeszcze wygenerować sekwencje instrukcji \emph{push}, które zapiszemy
do pliku \emph{ctf.push}. Skrypt generujący te instrukcję nazwiemy \emph{ctf.py}.

\begin{minted}{python}
import random

flag = input()
max = 0x7FFF

for f in flag[::-1]:
    x = ord(f)
    rand = random.randint(0, max // x)
    print("push", ~(rand * x))
    print("push", rand)
\end{minted}

Pobiera on flagę ze standardowego wejścia, a następnie dla każdego znaku flagi
(przechodząc po nich od tyłu) generuje dwie instrukcje \emph{push}.
Pierwsza z nich wrzuca zanegowany iloczyn losowej liczby ze znakiem flagi.
Druga wrzuca samą losową liczbę. Opiera się to na następującym równaniu:
\( \neg x \oplus x = -1 \).

Możemy teraz przystąpić do finalnej kompilacji. Najpierw generujemy sekwencje
instrukcji \emph{push} i zapisujemy je do pliku \emph{ctf.push}.

\begin{minted}{text}
$ ctf.py > ctf.push
AGH{600-vm}
\end{minted}

Następnie asemblujemy kod programu uruchamianego w środku maszyny wirtualnej
do pliku \emph{ctf.rom}.

\begin{minted}{text}
$ nasm ctf.nasm -o ctf.rom
\end{minted}

Konwertujemy plik \emph{ctf.rom} na tablicę \emph{char[]} języka C, dzięki czemu
będziemy mogli zamieścić program bezpośrednio w pliku wykonywalnym maszyny
wirtualnej.

\begin{minted}{text}
$ xxd -i ctf.rom > ctf.h
\end{minted}

Plik źródłowy maszyny wirtualnej załącza ten plik dyrektywą \emph{include}.
Kompilujemy więc finałowy program, który będzie zadaniem gotowym do uruchomienia.

\begin{minted}{text}
$ gcc -g -std=c99 vm.c -o vm
\end{minted}

\chapter{Organizacja pracy}

Praca nad projektem została rozpoczęta na szóstym semestrze od zrobienia zadania \emph{600-vm}.
Proces planowania tego zadania rozpoczął się od wymyślenia jak będzie wyglądało
przykładowe rozwiązanie zadania od strony użytkownika
końcowego -- jakich narzędzi mógłby przykładowo użyć i w jaki konkretny sposób ich wykorzystać
w celu zdobycia flagi. Następnie przystąpiono do implementacji programu.
To zadanie z racji największego poziomu trudności zajęło
najwięcej czasu. Pierwotnym pomysłem było stworzenie maszyny wirtualnej z rejestrami
i napisanie na nią programu we własnym asemblerze podobnym do x86. Jednak po zmianie zdania
napisana została od początku maszyna wirtualna oparta o stos zamiast rejestry.
Dzięki temu zadanie było ciekawsze do rozwiązywania.
Jako systemu kontroli wersji zostało użyte narzędzie
Git\footnote{\url{https://git-scm.com/}} wraz z hostowaniem na platformie GitHub\footnote{
\url{https://github.com/piotrek-szczygiel/bachelor-thesis}}.

Kiedy pierwsze zadanie było gotowe, należało wymyślić sposób udostępniania zadań
dla uczestników. Po przeglądnięciu kilku projektów zdecydowano się skorzystać
z platformy \emph{CTFd}, ponieważ była jedyną spełniającą następujące warunki: darmowa, aktualizowana
na bieżąco oraz możliwa do uruchomienia w kontenerze dockerowym.

Po wybraniu odpowiedniej platformy uruchomiono ją na prywatnym serwerze i skonfigurowano
domenę \url{https://ctf.szczygiel.dev/}, aby wskazywała na uruchomioną już platformę.
Wrzucono tam pierwsze zadanie i po przetestowaniu działania strony uznano, że sprawdzi
się dobrze do celów projektu.

Na siódmym semestrze można się więc było skupić już tylko na tworzeniu
nowych zadań. Zaplanowano, że będą one tworzone w kolejności od najłatwiejszego
do najtrudniejszego. Po wymyśleniu pomysłu na zadanie, próbowano
je zaimplementować, a następnie samemu rozwiązać i ocenić, czy nadaję się do projektu.
Zaczęto od zadań z najniższym poziomem trudności. Proces tworzenia wyglądał
podobnie jak poprzednio. Wymyślano sposób rozwiązania zadania o odpowiednim poziomie
trudności, a następnie implementowano program w taki sposób, aby użytkownik był
w stanie je rozwiązać używając założonych metod.
Kiedy zakończono implementacje sześciu zadań,
ponownie po kolei próbowano rozwiązać każde zadanie.
Przy tej okazji naniesiono dużo poprawek do programów,
które miały na celu dostosowanie poziomu trudności każdego zadania. W trakcie
pisania dokumentacji nie umieszczono prawdziwych flag, które będą rozwiązaniami na stronie.
W tym celu więc tymczasowo zmieniono każdy program, aby prawidłową flagą była
sama nazwa zadania. Po opisaniu procesu rozwiązywania zadań wraz ze zrzutami ekranu
przywrócono programy do wersji z pierwotnymi flagami.

\chapter{Wyniki projektu}

\section{Produkt końcowy}

Aby rozpocząć rozwiązywanie zadań użytkownik musi się udać na stronę internetową
projektu -- \url{https://ctf.szczygiel.dev/}.

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{ui_challenges}
\caption{Interfejs użytkownika z listą zadań do rozwiązania}
\end{figure}

Użytkownikowi po zalogowaniu się na swoje wcześniej stworzone konto oraz
wybraniu zadania, które chciałby rozwiązać pokazuje się okno
z opisem zadania lub plikiem do pobrania. Jest tam również miejsce
na wprowadzenie flagi, która jest jego rozwiązaniem.
Opis przykładowych rozwiązań znajduje się w dodatku \nameref{chap:writeups}.

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{ui_download}
\caption{Interfejs użytkownika z konkretnym zadaniem do rozwiązania}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{ui_solved}
\caption{Interfejs użytkownika po wprowadzeniu prawidłowej flagi}
\end{figure}

\section{Testy}

Tematyka projektu nie pozwalała na stworzenie testów jednostkowych ani automatycznych.
Prawidłowe działanie poszczególnych zadań było weryfikowane manualnie według scenariuszy
przedstawionych w dodatku \nameref{chap:writeups}.

\section{Propozycje dalszych prac}

Dalsze prace nad projektem mogą głównie opierać się na dodawaniu kolejnych zadań.
Oznaczałoby to znalezienie innych, ciekawych pomysłów na zadania, które
wykorzystywałyby nieużyte w tej pracy techniki inżynierii wstecznej.
Mogłyby to być przykładowo programy skompilowane na inne architektury procesora,
programy podatne na różnego rodzaju ataki niezgłębione w tym projekcie
jak np. integer overflow. Można by nawet stworzyć jakąś większą, pełnoprawną
aplikacje pokroju serwera WWW z luką w zabezpieczeniach, którą użytkownik musiałby znaleźć
i wykorzystać do przeprowadzenia ataku.
Możliwości tutaj jest nieskończoność i jedynym ograniczeniem tak na prawdę jest czas
jaki jest potrzebny na stworzenie każdego z kolejnych wyzwań.

\section{Podsumowanie}

Przed rozpoczęciem projektu interesowałem się zagadnieniami inżynierii wstecznej, jednak
nie miałem z nią żadnego większego doświadczenia poza okazyjnym czytaniem artykułów
i rozwiązaniem kilku prostych zadań. W trakcie pisania tej pracy pogłębiłem
swoją wiedzę na temat następujących narzędzi oraz zagadnień:

\begin{itemize}
    \item Korzystanie z programów do deasemblacji i analizy plików wykonywalnych
        \emph{Ghidra}, \emph{Cutter} oraz \emph{IDA}
    \item Korzystanie z debuggera \emph{GDB}
    \item Tworzenie prostej maszyny stosowej z niestandardowym kodem maszynowym
    \item Ataki przepełnienia bufora
    \item Działanie stack canary oraz randomizacji układu przestrzeni adresowej
        w systemach operacyjnych
    \item Tworzenie dockerowego kontenera zawierającego gotowy do połączenia przez
        protokół SSH system Linux
\end{itemize}

W projekcie udało się utworzyć grę, w której każda chętna osoba może sprawdzić
swoich sił. Przedstawiony zestaw zadań o tematyce inżynierii wstecznej
sprawdzi różne umiejętności uczestnika z zakresu działania systemów operacyjnych,
procesorów, plików wykonywalnych oraz rozwiązywania problemów z użyciem specjalistycznych
narzędzi.


\begin{appendices}
\chapter{Przykładowe rozwiązania zadań}
\label{chap:writeups}

W tym dodatku przedstawione zostaną przykładowe sposoby rozwiązania poszczególnych zadań.
Podobnie jak w rozdziale opisującym proces tworzenia tych zadań, znalezione
flagi są przykładowe.

\section{Zadanie 100-simple}

Po otworzeniu karty z pierwszym zadaniem uczestnik pobiera załączony do niego
plik -- \emph{simple}.
Na początku sprawdza z jakim rodzajem pliku ma do czynienia.

\begin{minted}[breaklines]{text}
$ file simple
simple: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=4bfaf13eb10701fb33b5442a8e17056253509ef1, for GNU/Linux 3.2.0, with debug_info, not stripped
\end{minted}

Jak zauważa, jest to plik wykonywalny dla 64-bitowego systemu Linux.
Uruchamia więc program, aby sprawdzić jego zachowanie.

\begin{minted}{text}
$ ./simple
Enter the flag: test
Incorrect flag!
\end{minted}

Na początku rozwiązywania każdego zadania z kategorii Reverse Engineering, warto
przejrzeć, czy plik wykonywalny nie zawiera jakiś przydatnych ciągów znaków.

\begin{minted}{text}
$ strings simple
/lib64/ld-linux-x86-64.so.2
puts
__stack_chk_fail
...
Enter the flag: 
AGH{100-simple}
Correct flag!
Incorrect flag!
...
\end{minted}

Zauważa ciekawie wyglądający ciąg znaków \emph{AGH\{100-simple\}}.
Uruchamia więc program jeszcze raz, podając mu ten ciąg znaków na wejście.

\begin{minted}{text}
$ ./simple
Enter the flag: AGH{100-simple}
Correct flag!
\end{minted}

Otrzymuje informację, że jest to prawidłowa flaga.
Po wpisaniu go na stronie zadania dowiaduje się, że jest to prawidłowe rozwiązanie.

\section{Zadanie 200-game}

Użytkownikowi po pobraniu oraz uruchomieniu załączonego pliku \emph{game.exe} ukazuję
się następujące okienko.

\begin{figure}[H]
\centering
\includegraphics{200_not_unlocked}
\caption{Okienko programu z informacją o braku dostępu do flagi}
\end{figure}

Użytkownik otwiera plik wykonywalny w programie IDA\footnote{
Darmowa wersja programu IDA przeznaczona do użytku domowego dostępna do pobrania pod adresem 
\url{https://www.hex-rays.com/products/ida/support/download_freeware}},
aby zapoznać się z działaniem programu.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{200_ida_graph}
\caption{Widok grafowy w programie IDA przestawiający główną pętle programu}
\end{figure}

Zauważa on, że wywołanie funkcji o nazwie \emph{\_show\_flag} decyduję o wyborze jednego
z dwóch węzłów wywołania programu. Biorąc pod uwagę nazwę tej funkcji oraz tekst
wyświetlany w prawym węźle (\textit{,,You have not unlocked access to the fla''...}), domyśla
się, że funkcja \emph{\_show\_flag} decyduję o tym czy flaga zostanie wyświetlona użytkownikowi.

\begin{figure}[H]
\centering
\includegraphics{200_ida_show_flag}
\caption{Funkcja \emph{\_show\_flag} w grafowym widoku programu IDA}
\end{figure}

Jedyne co ta funkcja robi to zwraca liczbę 0 -- czyli \emph{false}.
Próbuję on więc spatchować\footnote{Patchowanie w tym wypadku oznacza modyfikowanie programu
wykonywalnego poprzez nadpisanie konkretnych bajtów}
program, aby funkcja ta zwracała 1 -- czyli \emph{true}.

\begin{figure}[H]
\centering
\includegraphics{200_ida_patch}
\caption{Modyfikacja instrukcji \emph{mov eax, 0} na \emph{mov eax, 1} w programie IDA}
\end{figure}

Po zaaplikowaniu patch'a oraz ponownym uruchomieniu programu użytkownikowi ukazuję się
następujący widok.

\begin{figure}[H]
\centering
\includegraphics{200_flag}
\caption{Okienko programu wraz z otrzymaną flagą}
\end{figure}

Po wpisaniu na stronie flagi \emph{AGH\{200-game\}} użytkownik otrzymuję informację
o poprawnym rozwiązaniu zadania.

\section{Zadanie 300-strcmp}

Użytkownik pobiera plik \emph{strcmp} i sprawdza go programem \mintinline{text}{file}.

\begin{minted}[breaklines]{text}
$ file strcmp
strcmp: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=bda67999b52d8f4d1f9456346119790c47c261d8, for GNU/Linux 3.2.0, stripped
\end{minted}

Dowiaduje się, że jest to 64-bitowy plik wykonywalny na platformę Linux.
Uruchamia więc go, aby sprawdzić jego działanie.

\begin{minted}{text}
$ ./strcmp
Enter the flag: test
Incorrect flag!
\end{minted}

Aby przeanalizować działanie programu otwiera go w darmowym narzędziu Cutter\footnote{\url{https://cutter.re/}}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{300_cutter}
\caption{Widok grafowy funkcji \emph{main} w narzędziu Cutter}
\end{figure}

Zauważa, że za sprawdzenie poprawności flagi odpowiada funkcja \emph{strcmp}, która
jako jednego z argumentów używa niemodyfikowanego wejścia użytkownika.
Oznacza to, że flaga również musi być przekazana w jawnej formie do tej funkcji.
Korzysta on więc z GNU Debugger, aby odczytać przekazany do niej drugi parametr.

\begin{minted}{text}
$ gdb -q strcmp
Reading symbols from strcmp...
(No debugging symbols found in strcmp)
(gdb) info functions strcmp
All functions matching regular expression "strcmp":

Non-debugging symbols:
0x0000000000001070  strcmp@plt
\end{minted}

Zakłada teraz punkt przerwania w momencie wywołania funkcji \emph{strcmp}.

\begin{minted}{text}
(gdb) break strcmp@plt
Breakpoint 1 at 0x1070
\end{minted}

Uruchamia program i wpisuje dowolny tekst, aby przejść do punktu przerwania.

\begin{minted}{text}
(gdb) run
Starting program: /home/piotr/strcmp 
Enter the flag: test

Breakpoint 1, 0x0000555555555070 in strcmp@plt ()
\end{minted}

Kiedy program zatrzyma się w pożądanym miejscu, użytkownik podgląda zawartość pamięci na którą
zgodnie z konwencją wywołania System V AMD64\footnote{
\url{https://en.wikipedia.org/wiki/X86_calling_conventions\#System_V_AMD64_ABI}}
wskazują rejestry RDI oraz RSI - czyli dwa parametry przekazane do funkcji \emph{strcmp}.

\begin{minted}{text}
(gdb) x/s $rdi
0x7fffffffe2b0: "test"
(gdb) x/s $rsi
0x555555558050: "AGH{300-strcmp}"
\end{minted}

W rejestrze RDI znajduję się adres tekstu wpisanego przez użytkownika, natomiast
w rejestrze RSI ciąg znaków, z którym wejście od użytkownika jest porównywane -- czyli
jawna postać flagi. W taki sposób użytkownik otrzymuję flagę \emph{AGH\{300-strcmp\}},
która jest rozwiązaniem tego zadania.

\section{Zadanie 400-decrypt}

Użytkownik pobiera plik \emph{decrypt} i podobnie jak wcześniej
sprawdza go programem \mintinline{text}{file}.

\begin{minted}[breaklines]{text}
$ file decrypt
decrypt: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8b4924f98f391fb9939f323d9a89e37d2e7febb7, for GNU/Linux 3.2.0, not stripped
\end{minted}

Podobnie jak w poprzednim zadaniu, dowiaduję się, że jest to 64-bitowy linuksowy program.
Uruchamia go.

\begin{minted}{text}
$ ./decrypt
Enter the flag: test
Incorrect flag!
\end{minted}

Tym razem do analizy programu użyje narzędzia Ghidra\footnote{\url{https://ghidra-sre.org/}}.
Potrafi ona zamieniać kod maszynowy programu na psuedokod C, co bardzo ułatwia
analizowanie plików wykonywalnych.
Użytkownik wczytuje pobrany plik wykonywalny do narzędzia i uruchamia widok dekompilatora
dla funkcji \emph{main}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{400_main}
\caption{Widok dekompilatora dla funkcji \emph{main} w narzędziu Ghidra}
\end{figure}

Zauważa, że powyższy fragment kodu szyfruje tekst wprowadzony przez użytkownika,
a następnie porównuje go z ciągiem znaków zawartym w zmiennej \emph{flag}.
Następnie analizuje zdekompillwany kod funkcji \emph{encrypt} zmieniając nazwy zmiennych
dla poprawy czytelności.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{400_encrypt}
\caption{Widok dekompilatora dla funkcji \emph{encrypt} w narzędziu Ghidra}
\end{figure}

Zauważa, że funkcja szyfrująca dzieli się na dwa fragmenty.
Pierwszy fragment przechodzi po każdym znaku tablicy wejściowej i dodaje
\emph{'\textbackslash r'} lub
odejmuje \emph{0xd} w zależności czy dany znak spełnia warunki.
Zarówno \emph{'\textbackslash r'} jak i \emph{0xd} to 13 w systemie dziesiętnym.
Analizując warunki dochodzi do wniosku, że jest to prosty szyfr przesuwający zwany ROT13.
Drugi fragment również przechodzi po każdym znaku tablicy, a następnie wykonuje
operacje XOR z kolejnymi bajtami klucza. Po przekroczeniu ostatniego bajtu klucza
wraca do pierwszego, co zapewnia operacja \mintinline{c}{k = k + 1 & 3}.
Biorąc pod uwagę, że liczby całkowite przechowywane
są w pamięci w formie Little Endian, to klucz również można zapisać następująco:
\emph{0xde, 0xad, 0xbe, 0xef}. Następnie podgląda zawartość tablicy \emph{flag}.

\begin{figure}[H]
\centering
\includegraphics{400_flag}
\caption{Zawartość tablicy \emph{flag} w widoku Listing narzędzia Ghidra}
\end{figure}

Posiadając te informacje pisze skrypt w języku Python, który odwróci wcześniej otrzymaną
tablice \emph{flag} do wartości pierwotnej.

\begin{minted}[breaklines]{python}
flag = [0x90, 0xf9, 0xeb, 0x94, 0xea, 0x9d, 0x8e, 0xc2, 0xaf, 0xdf, 0xce, 0x8a, 0xb2, 0xce, 0xd9, 0x92]

key = [0xde, 0xad, 0xbe, 0xef]
for i in range(len(flag)):
    flag[i] ^= key[i % len(key)]

for i in range(len(flag)):
    c = flag[i]

    if c >= ord("A") and c <= ord("Z"):
        if c + 13 <= ord("Z"):
            flag[i] = c + 13
        else:
            flag[i] = c - 13
    elif c >= ord("a") and c <= ord("z"):
        if c + 13 <= ord("z"):
            flag[i] = c + 13
        else:
            flag[i] = c - 13

print("".join([chr(x) for x in flag]))
\end{minted}

Zapisuje skrypt jako \emph{decrypt.py} i uruchamia go.

\begin{minted}{text}
$ python decrypt.py
AGH{400-decrypt}
\end{minted}

Otrzymuje rozwiązanie tego zadania, czyli flagę \emph{AGH\{400-decrypt\}}.

\section{Zadanie 500-secret-shell}

W tym zadaniu zamiast pliku do pobrania, użytkownik otrzymuje następującą informację:

\begin{minted}{text}
$ ssh ctf@szczygiel.dev -p 2222
ctf@szczygiel.dev's password: agh-reverse-engineering
\end{minted}

Uruchamia więc terminal i zgodnie ze wskazówkami loguje się na zadany host.
W katalogu \emph{/home/admin/} znajduje następujące pliki:

\begin{minted}{text}
ctf@d35da2ee92fe:/home/admin$ ls -l
total 20
-rw------- 1 admin admin    22 Dec 11 21:26 access_code.txt
-rwsr-xr-x 1 admin admin 16332 Dec 11 21:26 secret-shell
\end{minted}

Zauważa plik \emph{access\_code.txt}, w którym prawdopodobnie znajduję się flaga.
Niestety użytkownik \emph{ctf} nie posiada uprawnień do odczytania tego pliku.
Jest też plik wykonywalny z ustawionym bitem SUID.
Oznacza to, że można uruchomić program \emph{secret-shell} z prawami użytkownika \emph{admin}.
Uruchamia więc program \emph{secret-shell}.

\begin{minted}{text}
ctf@d35da2ee92fe:/home/admin$ ./secret-shell
Welcome, enter your name: Piotr
Hello, Piotr

Enter the access code: test
Access denied!
\end{minted}

Pobiera ten program na lokalny komputer w celu jego przeanalizowania.

\begin{minted}{text}
$ scp -P 2222 ctf@szczygiel.dev:/home/admin/secret-shell .
\end{minted}

Analizuje go narzędziem Ghidra. Otrzymuje informację, że jest to 32-bitowy program
na system Linux. Rzuca mu się w oczy funkcja \emph{greeter} w której
imie użytkownika pobierane jest niebezpieczną funkcją \emph{gets}. Jest ona niebezpieczna,
ponieważ nie kontroluje ona długości pobieranego wejścia i może prowadzić do przepełnienia
bufora \emph{name} o rozmiarze 72 bajtów.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{500_greeter}
\caption{Widok dekompilatora dla funkcji \emph{greeter} w narzędziu Ghidra}
\end{figure}

Znajduję również funkcję \emph{access\_secret\_shell}, która uruchamia powłokę systemową.
Pamiętając o ustawionym bicie SUID, oznacza to, że uruchomiona powłoka będzie z uprawnieniami
użytkownika \emph{admin}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{500_access}
\caption{Widok dekompilatora dla funkcji \emph{access\_secret\_shell} w narzędziu Ghidra}
\end{figure}

Sprawdza zabezpieczenia programu wykonywalnego skryptem \mintinline{text}{checksec.sh}\footnote{
\url{https://github.com/slimm609/checksec.sh}} i dowiaduje się, że wyłączony jest Stack Canary
oraz że plik nie jest position-independent executable\footnote{
\url{https://en.wikipedia.org/wiki/Position-independent_code}}.
Dochodzi więc do wniosku, że będzie mógł on wykonać atak Stack buffer overflow
nadpisujący adres powrotu z funkcji \emph{greeter}.

Odpowiednio przepełniając bufor \emph{name}, będzie on mógł nadpisać adres powrotu
funkcji. Dzięki temu po wyjściu z funkcji \emph{greeter} program przeniesie się do
wskazanego przez niego miejsca.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{500_stack}
\caption{Zawartość stosu funkcji \emph{greeter} przed i po ataku}
\end{figure}

Aby rozwiązać zadanie, będzie potrzebował znaleźć takie miejsce w programie, gdzie
po przeniesieniu się do niego uzyska w jakiś sposób dostęp do pliku \emph{access\_code.txt}.
Idealnym do tego miejscem jest funkcja \emph{access\_secret\_shell}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{500_bin_sh_address}
\caption{Fragment funkcji \emph{access\_secret\_shell} uruchamiający powłokę}
\end{figure}

Wybrany przez niego adres to \emph{080494a4} -- kiedy wykonanie programu przeniesie się w to miejsce,
na stos zostanie wrzucony wskaźnik do ciągu \mintinline{text}{/bin/sh}, a następnie zostanie wywołana
funkcja \emph{system}, tym samym uruchamiając powłokę systemową. Wtedy korzystając z poleceń
powłoki będzie mógł wyświetlić zawartość pliku \emph{access\_code.txt}.

Pozostaje mu więc tylko przygotować exploit, który przepełni bufor
w taki sposób, aby adres powrotu wskazywał właśnie na to miejsce. Musi też pamiętać
o tym, że adresy w pamięci przechowywane są w formacie Little Endian, więc adres
\emph{080494a4} będzie musiał przekazać jako \emph{a4940408}.

Przygotowuje więc prosty jednolinijkowiec w języku Python 2, wypisujący ciąg znaków,
który wypełni bufor oraz zapisany rejestr EBP literkami \emph{A},
a następnie doda pożądany adres:

\mintinline{python}{print 'A' * 76 + '\xa4\x94\x04\x08'}

\begin{figure}[H]
\centering
\includegraphics[width=6cm]{500_overflow}
\caption{Zawartość stosu funkcji \emph{greeter} po wykonaniu exploita}
\end{figure}

Pozostało mu już tylko wykonać exploit na zdalnej maszynie. Jednak samo przekazanie
wyjścia tego skryptu na wejście programu \emph{secret-shell} nie zadziała, ponieważ
po przekazaniu pożądanego ciągu znaków zamknie się standardowe wejście.
Z tego powodu powłoka \mintinline{text}{/bin/sh} natychmiast się wyłączy.

Korzysta on więc z prostego triku, który po wywołaniu programu zachowuje dostęp
do standardowego wejścia, dzięki programowi \mintinline{text}{cat}.

\begin{minted}[breaklines]{text}
ctf@de4848f994a7:/home/admin$ (python2 -c "print 'A' * 76 + '\xa4\x94\x04\x08'"; cat) | ./secret-shell
\end{minted}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{500_solution}
\caption{Uruchomienie exploita i rozwiązanie zadania}
\end{figure}

W taki sposób otrzymuje rozwiązanie zadania, czyli flagę \emph{AGH\{500-secret-shell\}}.

\section{Zadanie 600-vm}

Użytkownik pobiera plik \emph{vm} i sprawdza go programem \mintinline{text}{file}.

\begin{minted}[breaklines]{text}
$ file vm
vm: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=bfe399afd61b8d0bfe73a724b7866f67498435c4, for GNU/Linux 3.2.0, with debug_info, not stripped
\end{minted}

Z racji, że jest to 64-bitowy program na system Linux, uruchamia go.

\begin{minted}{text}
$ ./vm
Enter the flag: test
Incorrect flag!
\end{minted}

Schemat taki sam jak w poprzednich zadaniach -- wprowadza flagę i otrzymuje informację
o tym, czy jest ona prawidłowa. Ponownie korzysta on więc z narzędzia Ghidra, aby
przeanalizować działanie programu.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{600_main}
\caption{Widok dekompilatora dla funkcji \emph{main} w narzędziu Ghidra}
\end{figure}

Widzi, że za sprawdzenie flagi odpowiada funkcja \emph{vm\_run} -- analizuje więc on
funkcje z przedrostkami \emph{vm\_}. Zaczyna od funkcji \emph{vm\_init}, która jest
wywoływana na samym początku programu\footnote{Przedstawiony kod funkcji w tym podrozdziale
jest bezpośrednio przekopiowany z widoku dekompilatora narzędzia Ghidra}.

\begin{minted}{c}
void vm_init(VM *vm)

{
  vm->ip = vm->mem + 0x1337;
  vm->sp = vm->stack;
  vm->input_ptr = vm->input;
  return;
}
\end{minted}

Widzi, że funkcja inicjalizuje przekazaną do niej zmienną typu \emph{VM}.
Sprawdza więc w widoku \emph{Structure Editor} jakie pola ta struktura zawiera.

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{600_struct}
\caption{Widok \emph{Structure Editor} dla typu danych \emph{VM} w narzędziu Ghidra}
\end{figure}

Po nazwach zmiennych domyśla się, że jest to struktura dla swego rodzaju maszyny wirtualnej
-- stąd przedrostki \emph{vm\_} (virtual machine). I tak kolejno \emph{mem} jest prawdopodobnie
pamięcią maszyny, \emph{ip} -- instruction pointer, czyli wskaźnik na aktualną instrukcje,
\emph{stack} oraz \emph{sp} to kolejno stos oraz wskaźnik na ostatni jego element, a \emph{input}
oraz \emph{input\_ptr} to prawdopodobnie jakieś wejście użytkownika wraz ze wskaźnikiem.

Wracając więc do funkcji \emph{vm\_init} widzi, że wskaźnik \emph{vm->ip} na początku wskazuje
tam gdzie \emph{vm->mem} z przesunięciem o \emph{0x1337} bajtów. Wskaźnik \emph{vm->sp} ustawia
się na \emph{vm->stack}, czyli początek stosu. Podobnie wskaźnik \emph{vm->input\_ptr} ustawia
się po prostu na \emph{vm->input}.
Przechodzi do analizowanie kolejnej funkcji wywoływanej zaraz po \emph{vm\_init} -- czyli
\emph{vm\_load}.

\begin{minted}{c}
void vm_load(VM *vm,uint8_t *rom,size_t rom_size)

{
  memcpy(vm->mem + 0x1337,rom,rom_size);
  return;
}
\end{minted}

Widzi, że ładuje ona dane do pamięci również z takim samym przesunięciem, jak wcześniej
ustawiony był \emph{instruction pointer}. Domyśla się więc, że ta funkcja odpowiada za
załadowanie programu do pamięci maszyny wirtualnej.

Następnie analizuje funkcje \emph{vm\_fill\_input} do której przekazywany jest tekst
wprowadzony przez użytkownika.

\begin{minted}{c}
void vm_fill_input(VM *vm,char *input,int size)

{
  if (0x80 < size) {
                    /* WARNING: Subroutine does not return */
    exit(5);
  }
  memcpy(vm->input,input,(long)size);
  return;
}
\end{minted}

Funkcja sprawdza najpierw czy rozmiar wejścia nie przekracza \emph{0x80}, czyli 128 znaków.
Następnie kopiuje podany bufor \emph{input} do zmiennej \emph{vm->input}.
Użytkownik wie już zatem, że zmienna \emph{vm->input} zawiera wprowadzoną przez niego flagę.

Zabiera się teraz za analizę funkcji \emph{vm\_run} -- czyli serca maszyny wirtualnej.
Najpierw jednak sprawdza działanie funkcji pomocniczych, których użycia znajduje w środku
funkcji \emph{vm\_run}.

\begin{minted}{c}
uint8_t vm_read_byte(VM *vm)

{
  uint8_t *puVar1;
  
  puVar1 = vm->ip;
  vm->ip = puVar1 + 1;
  return *puVar1;
}
\end{minted}

\begin{minted}{c}
short vm_read_short(VM *vm)

{
  vm->ip = vm->ip + 2;
  return CONCAT11(vm->ip[-1],vm->ip[-2]);
}
\end{minted}

Dochodzi do wniosku, że funkcje \emph{vm\_read\_byte} oraz \emph{vm\_read\_short}
zwracają liczbę jedno lub dwu-bajtową pod wskaźnikiem \emph{vm->ip},
a następnie przesuwają ten wskaźnik na instrukcje za tą liczbą.
Funkcja \emph{CONCAT11}, jak wyczytał w dokumentacji narzędzia Ghidra -- skleja
dwa bajty w jedną liczbę. Z racji, że bajty sklejane są w odwrotnej kolejności --
oznacza to, że liczby przechowywane są w pamięci maszyny wirtualnej w formacie Little Endian.

\begin{minted}{c}
void vm_push(VM *vm,short value)

{
  short *psVar1;
  
  if (0x1fe < (long)((long)vm->sp - (long)vm->stack)) {
                    /* WARNING: Subroutine does not return */
    exit(3);
  }
  psVar1 = vm->sp;
  vm->sp = psVar1 + 1;
  *psVar1 = value;
  return;
}
\end{minted}

\begin{minted}{c}
short vm_pop(VM *vm)

{
  if (vm->sp == vm->stack) {
                    /* WARNING: Subroutine does not return */
    exit(4);
  }
  vm->sp = vm->sp + -1;
  return *vm->sp;
}
\end{minted}

Funkcje \emph{vm\_push} oraz \emph{vm\_pop} kolejno wrzucają lub ściągają dwubajtową
liczbę ze stosu. Po analizie funkcji pomocniczych przechodzi do analizy funkcji
\emph{vm\_run}.

Na początku tej funkcji znajduję się następujący fragment\footnote{Nazwa labela została
zmieniona na \emph{VM\_LOOP} dla ułatwienia czytelności}:

\begin{minted}{c}
// Pominięto definicje wielu zmiennych

VM_LOOP:
  byte op = vm_read_byte(vm);
\end{minted}

Czyli wczytanie aktualnej instrukcji do zmiennej o nazwie \emph{op}. Po tym fragmencie
następuję mnóstwo rozgałęzień \emph{if}. Analizuje on każde z osobna.

\begin{minted}{c}
if (op == 0xe1) {
  sVar4 = vm_read_short(vm);
  return (int)sVar4;
}
\end{minted}

Jeśli przeczytanym bajtem był \emph{0xe1}, to pobierana jest dwubajtowa liczba, a następnie
jest ona zwraca z funkcji \emph{vm\_run}. Oznacza to więc, że jest to swego rodzaju kod
zatrzymujący działanie maszyny wirtualnej z ustawionym statusem w postaci kolejno
wczytanej liczby.

\begin{minted}{c}
if (op == 0xdf) {
  sVar4 = vm_read_short(vm);
  if (vm->stack == vm->sp) {
    vm->ip = vm->mem + sVar4;
  }
  goto VM_LOOP;
}
\end{minted}

Instruckja \emph{0xdf} bierzę liczbę, a następnie sprawdza, czy zmienna \emph{vm->sp} wskazuje
w to samo miejsce co \emph{vm->stack} -- czyli sprawdza czy stos jest pusty. Jeśli tak
to ustawia zmienną \emph{vm->ip} na \emph{vm->mem} powiększoną o wartość pobranej liczby.

\begin{minted}{c}
if (op == 0xce) {
  sVar4 = vm_pop(vm);
  vm_push(vm,sVar4);
  vm_push(vm,sVar4);
  goto VM_LOOP;
}
\end{minted}

Instruckja \emph{0xce} pobiera liczbę ze stosu, a następnie wrzuca ją na stos dwa razy.
Można więc powiedzieć, że duplikuję ostatnią liczbę na stosie.

\begin{minted}{c}
if (op == 0xb1) {
  if (0x7f < (long)(vm->input_ptr + -(long)vm->input)) {
            /* WARNING: Subroutine does not return */
    exit(6);
  }
  pbVar1 = vm->input_ptr;
  vm->input_ptr = pbVar1 + 1;
  vm_push(vm,(ushort)*pbVar1);
  goto VM_LOOP;
}
\end{minted}

Instrukcja \emph{0xb1} wrzuca na stos znak na który wskazuję zmienna \emph{vm->input\_ptr},
a następnie przesuwa ten wskaźnik o jeden. Sprawdza również wcześniej czy zmienna
\emph{vm->input\_ptr} nie wyszła poza bufor \emph{vm->input}.

\begin{minted}{c}
if (op == 0xa4) {
  sVar4 = vm_read_short(vm);
  vm_push(vm,sVar4);
  goto VM_LOOP;
}
\end{minted}

Instrukcja \emph{0xa4} wrzuca na stos zadaną liczbę.

\begin{minted}{c}
if (op == 0xa2) {
  sVar4 = vm_pop(vm);
  sVar5 = vm_pop(vm);
  vm_push(vm,sVar5 * sVar4);
  goto VM_LOOP;
}
\end{minted}

Instrukcja \emph{0xa2} pobiera dwie liczby ze stosu, a następnie wrzuca na stos ich iloczyn.

\begin{minted}{c}
if (op == 0x9b) {
  vm_pop(vm);
  goto VM_LOOP;
}
\end{minted}

Instrukcja \emph{0x9b} pobiera liczbę ze stosu i nic z nią nie robi.

\begin{minted}{c}
if (op == 0x66) {
  sVar4 = vm_pop(vm);
  vm_push(vm,sVar4 + 1);
  goto VM_LOOP;
}
\end{minted}

Instrukcja \emph{0x66} pobiera liczbę ze stosu i wrzuca ją z powrotem na stos powiększoną o 1.

\begin{minted}{c}
if (op == 0x03) {
  uVar2 = vm_pop(vm);
  uVar3 = vm_pop(vm);
  vm_push(vm,uVar2 ^ uVar3);
  goto VM_LOOP;
}
\end{minted}

Instrukcja \emph{0x03} pobiera dwie liczby ze stosu, a następnie wrzuca na stos wynik operacji
XOR na tych dwóch liczbach.

\begin{minted}{c}
else {
  if (op != 0x52) goto VM_EXIT;
  sVar4 = vm_read_short(vm);
  sVar5 = vm_pop(vm);
  if (sVar5 == 0) {
    vm->ip = vm->mem + sVar4;
  }
  goto VM_LOOP;
}
\end{minted}

Instrukcja \emph{0x52} sprawdza czy ostatnia liczba na stosie jest równa 0, jeśli tak
to przenosi działanie programu we wskazane miejsce. Jeśli po dojściu do tego miejsca
nie udało się dopasować instrukcji, to program przechodzi do \emph{VM\_EXIT}.

\begin{minted}{c}
VM_EXIT:
                    /* WARNING: Subroutine does not return */
  exit(2);
\end{minted}

Aby uporządkować sobie zdobyte informację, użytkownik tworzy tabelę instrukcji.

\begin{table}[H]
\resizebox{\textwidth}{!}{%
\begin{tabular}{@{}llll@{}}
\toprule
Instrukcja & Ilość zmiennych & Nazwa & Opis \\ \midrule
0xe1 & 1 & HALT & Zatrzymaj maszynę z podanym kodem wyjścia \\
0xdf & 1 & JUMP\_EMPTY & Skocz w zadane miejsce, jeśli stos jest pusty \\
0xce & 0 & DUPLICATE & Zduplikuj ostatnią liczbę na stosie \\
0xb1 & 0 & PUSH\_INPUT & Wrzuć na stos kolejny znak z wejścia użytkownika \\
0xa4 & 1 & PUSH & Wrzuć na stos podaną liczbę \\
0xa2 & 0 & MULTIPLY & Pomnóż dwie ostatnie liczby na stosie \\
0x9b & 0 & POP & Zdejmij ostatnią liczbę ze stosu \\
0x66 & 0 & INCREMENT & Powiększ o 1 ostatnią liczbę na stosie \\
0x03 & 0 & XOR & Wykonaj operację XOR dla dwóch ostatnich liczb na stosie \\
0x52 & 1 & JUMP\_ZERO & Skocz w zadane miejsce, jeśli ostatnią liczbą na stosie jest 0 \\ \bottomrule
\end{tabular}%
}
\caption{Tabela instrukcji maszyny wirtualnej}
\end{table}

Użytkownik w celu zrozumienia działania programu będzie musiał stworzyć deasembler dla maszyny wirtualnej.
Najpierw jednak musi zdobyć zawartość tablicy \emph{ctf\_rom}, która przechowuje uruchamiany w tej maszynie program.

\begin{figure}[H]
\centering
\includegraphics[width=7cm]{600_rom}
\caption{Zawartość tablicy \emph{ctf\_rom} w widoku Listing narzędzie Ghidra}
\end{figure}

Posiadając wszystkie potrzebne rzeczy, użytkownik zaczyna pisanie deasemblera.
Skorzysta w tym celu z języka Python. Korzystając z funkcjonalności narzędzia Ghidra
kopiuje tablicę \emph{ctf\_rom} jako ciąg heksadecymalny. W swoim skrypcie
zamienia go na tablicę liczb.

\begin{minted}[breaklines]{python}
import struct

rom = "a4 55 c8 a4 72 00 a4 f9 d7 a4 5e 00 a4 19 b2 a4 a9 00 a4 84 f3 a4 47 00 a4 3f ab a4 c4 01 a4 df 80 a4 a6 02 a4 dd f1 a4 43 00 a4 48 8a a4 f5 00 a4 bf c7 a4 c8 00 a4 b5 9c a4 66 01 a4 3c ff a4 03 00 b1 ce 52 87 13 a2 03 66 52 79 13 e1 01 00 9b df 8e 13 e1 01 00 e1 00 00"

rom = [int(x, 16) for x in rom.split(" ")]
\end{minted}

Definiuje zmienną \emph{ip}, która będzie przechowywać indeks tablicy \emph{rom} oraz tworzy
funkcję wczytującą dwubajtową liczbę w formacie Little Endian.

\begin{minted}{python}
ip = 0


def read_short():
    global ip
    short = struct.unpack("h", bytes(rom[ip : ip + 2]))[0]
    ip += 2
    return short
\end{minted}

Następnie tworzy pętle, która przechodzi po programie i wyświetla informację o napotkanych instrukcjach.
Przed każdą instrukcją wyświetla wartość zmiennej \emph{ip} powiększoną o \emph{0x1337}, aby dostać
informację pod jakim wirtualnym adresem ta instrukcja się znajduję.

\begin{minted}{python}
while ip < len(rom):
    print(str(0x1337 + ip) + ":\t", end="")

    op = rom[ip]
    ip += 1

    if op == 0xe1:
        print(f"HALT {read_short()}")
    elif op == 0xdf:
        print(f"JUMP_EMPTY {read_short()}")
    elif op == 0xce:
        print("DUPLICATE")
    elif op == 0xb1:
        print("PUSH_INPUT")
    elif op == 0xa4:
        print(f"PUSH {read_short()}")
    elif op == 0xa2:
        print("MULTIPLY")
    elif op == 0x9b:
        print("POP")
    elif op == 0x66:
        print("INCREMENT")
    elif op == 0x03:
        print("XOR")
    elif op == 0x52:
        print(f"JUMP_ZERO {read_short()}")
    else:
        print(f"UNKNOWN OPCODE: {op}")
        break
\end{minted}

Uruchamia teraz swój deasembler.

\begin{minted}{text}
$ python disassemble.py 
4919:   PUSH -14251
...
4976:   PUSH 358
4979:   PUSH -196
4982:   PUSH 3
4985:   PUSH_INPUT
4986:   DUPLICATE
4987:   JUMP_ZERO 4999
4990:   MULTIPLY
4991:   XOR
4992:   INCREMENT
4993:   JUMP_ZERO 4985
4996:   HALT 1
4999:   POP
5000:   JUMP_EMPTY 5006
5003:   HALT 1
5006:   HALT 0
\end{minted}

Dla lepszego zrozumienia programu użytkownik tworzy sobie schemat blokowy jego działania
oraz schemat zawartości stosu.

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{600_flowchart}
\caption{Schemat blokowy działania programu}
\label{fig:600_flowchart}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=10cm]{600_stack}
\caption{Zawartość stosu w poszczególnych etapach działania programu}
\label{fig:600_stack}
\end{figure}

Dzięki tej wizualizacji zauważył, że aby obliczyć kolejny znak flagi \emph{x},
należy wziąć ze stosu liczbę \emph{a}, następnie liczbę \emph{b}
i obliczyć dla nich równanie \(b \oplus ax + 1 = 0\).
Przystępuje on więc do pisania programu znajdującego flagę.
Do tablicy \emph{stack} wpisuje liczby, które znajdowały się po instrukcji
\emph{PUSH} w wyniku działania deasemblera. Następnie metodą brute force\footnote{
\url{https://pl.wikipedia.org/wiki/Atak_brute_force}} szuka znaku, który spełnia
równanie i dodaje go do wynikowej flagi, którą na koniec wypisuje.

\begin{minted}[breaklines]{python}
stack = [-14251, 114, -10247, 94, -19943, 169, -3196, 71, -21697, 452, -32545, 678, -3619, 67, -30136, 245, -14401, 200, -25419, 358, -196, 3]
flag = []

while stack:
    a = stack.pop()
    b = stack.pop()

    for x in range(256):
        if b ^ (a * x) == -1:
            flag.append(x)
            break

print("".join([chr(x) for x in flag]))
\end{minted}

Uruchamia go i otrzymuje rozwiązanie zadania, czyli flagę \emph{AGH\{600-vm\}}.

\begin{minted}{text}
$ python solve.py
AGH{600-vm}
\end{minted}

\end{appendices}

\backmatter

\cleardoublepage
\listoffigures

%\cleardoublepage
%\printbibliography

\end{document}
